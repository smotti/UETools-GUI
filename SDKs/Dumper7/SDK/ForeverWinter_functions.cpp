#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ForeverWinter

#include "Basic.hpp"

#include "ForeverWinter_classes.hpp"
#include "ForeverWinter_parameters.hpp"


namespace SDK
{

// Function ForeverWinter.FWBarManager.AddBarItem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ItemTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWBarManager::AddBarItem(const struct FGameplayTag& ItemTag, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarManager", "AddBarItem");

	Params::FWBarManager_AddBarItem Parms{};

	Parms.ItemTag = std::move(ItemTag);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWBarManager.GetAllBarItems
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<struct FGameplayTag, int32>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, int32> UFWBarManager::GetAllBarItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarManager", "GetAllBarItems");

	Params::FWBarManager_GetAllBarItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWBarManager.GetBarItemCount
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ItemTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWBarManager::GetBarItemCount(const struct FGameplayTag& ItemTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarManager", "GetBarItemCount");

	Params::FWBarManager_GetBarItemCount Parms{};

	Parms.ItemTag = std::move(ItemTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWBarManager.RemoveBarItem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ItemTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWBarManager::RemoveBarItem(const struct FGameplayTag& ItemTag, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarManager", "RemoveBarItem");

	Params::FWBarManager_RemoveBarItem Parms{};

	Parms.ItemTag = std::move(ItemTag);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCoverNodeComponent.GetOccupiedBy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* USCoverNodeComponent::GetOccupiedBy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "GetOccupiedBy");

	Params::SCoverNodeComponent_GetOccupiedBy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.OccupyCover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::OccupyCover(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "OccupyCover");

	Params::SCoverNodeComponent_OccupyCover Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.OnNodeMovedHandler
// (Final, Native, Public, BlueprintCallable)

void USCoverNodeComponent::OnNodeMovedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "OnNodeMovedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCoverNodeComponent.ReleaseCover
// (Final, Native, Public, BlueprintCallable)

void USCoverNodeComponent::ReleaseCover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "ReleaseCover");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCoverNodeComponent.IsCrouchActionAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECoverCrouchActions               Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsCrouchActionAllowed(const ECoverCrouchActions Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsCrouchActionAllowed");

	Params::SCoverNodeComponent_IsCrouchActionAllowed Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsCrouchActionMaskAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsCrouchActionMaskAllowed(const int32 Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsCrouchActionMaskAllowed");

	Params::SCoverNodeComponent_IsCrouchActionMaskAllowed Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsCrouchAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsCrouchAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsCrouchAllowed");

	Params::SCoverNodeComponent_IsCrouchAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsFreeCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsFreeCover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsFreeCover");

	Params::SCoverNodeComponent_IsFreeCover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsProneActionAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECoverProneActions                Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsProneActionAllowed(const ECoverProneActions Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsProneActionAllowed");

	Params::SCoverNodeComponent_IsProneActionAllowed Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsProneActionMaskAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsProneActionMaskAllowed(const int32 Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsProneActionMaskAllowed");

	Params::SCoverNodeComponent_IsProneActionMaskAllowed Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsProneAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsProneAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsProneAllowed");

	Params::SCoverNodeComponent_IsProneAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsStandActionAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ECoverStandActions                Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsStandActionAllowed(const ECoverStandActions Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsStandActionAllowed");

	Params::SCoverNodeComponent_IsStandActionAllowed Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsStandActionMaskAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsStandActionMaskAllowed(const int32 Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsStandActionMaskAllowed");

	Params::SCoverNodeComponent_IsStandActionMaskAllowed Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCoverNodeComponent.IsStandAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCoverNodeComponent::IsStandAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCoverNodeComponent", "IsStandAllowed");

	Params::SCoverNodeComponent_IsStandAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.DataTableFunctionLib.RemoveRowFromDataTable
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableFunctionLib::RemoveRowFromDataTable(class UDataTable* DataTable, class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableFunctionLib", "RemoveRowFromDataTable");

	Params::DataTableFunctionLib_RemoveRowFromDataTable Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.DataTableFunctionLib.UpdateDataTable
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStruct*                          Data                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableFunctionLib::UpdateDataTable(const class UDataTable* DataTable, class FName RowName, class UStruct* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableFunctionLib", "UpdateDataTable");

	Params::DataTableFunctionLib_UpdateDataTable Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.ArePSOsCompiling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::ArePSOsCompiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "ArePSOsCompiling");

	Params::ForeverWinterBlueprintLibrary_ArePSOsCompiling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.BuildPaths
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForeverWinterBlueprintLibrary::BuildPaths(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "BuildPaths");

	Params::ForeverWinterBlueprintLibrary_BuildPaths Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.CharacterIsUnlocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPawnDefinition*          Pawn                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::CharacterIsUnlocked(const class UFWPawnDefinition* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "CharacterIsUnlocked");

	Params::ForeverWinterBlueprintLibrary_CharacterIsUnlocked Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.CompassRotationToTranslation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                InOwningPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float*                                  OutTranslationX                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutInRadarSight                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsClockwise                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForeverWinterBlueprintLibrary::CompassRotationToTranslation(class APlayerController* InOwningPlayer, const struct FRotator& InRotation, float* OutTranslationX, bool* OutInRadarSight, bool* OutIsClockwise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "CompassRotationToTranslation");

	Params::ForeverWinterBlueprintLibrary_CompassRotationToTranslation Parms{};

	Parms.InOwningPlayer = InOwningPlayer;
	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTranslationX != nullptr)
		*OutTranslationX = Parms.OutTranslationX;

	if (OutInRadarSight != nullptr)
		*OutInRadarSight = Parms.OutInRadarSight;

	if (OutIsClockwise != nullptr)
		*OutIsClockwise = Parms.OutIsClockwise;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.DisplayMessageForAllPlayers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class APlayerController*>& IgnoredPlayers                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class APlayerController*>& OtherPlayers                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      OtherPlayerMessage                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UForeverWinterBlueprintLibrary::DisplayMessageForAllPlayers(const class UObject* WorldContextObject, const class FText& Message, const TArray<class APlayerController*>& IgnoredPlayers, const TArray<class APlayerController*>& OtherPlayers, const class FText& OtherPlayerMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "DisplayMessageForAllPlayers");

	Params::ForeverWinterBlueprintLibrary_DisplayMessageForAllPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Message = std::move(Message);
	Parms.IgnoredPlayers = std::move(IgnoredPlayers);
	Parms.OtherPlayers = std::move(OtherPlayers);
	Parms.OtherPlayerMessage = std::move(OtherPlayerMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.GetCurrentMapName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UForeverWinterBlueprintLibrary::GetCurrentMapName(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "GetCurrentMapName");

	Params::ForeverWinterBlueprintLibrary_GetCurrentMapName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.GetMapDevStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMapEntryData&             Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EMapDevStatus                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMapDevStatus UForeverWinterBlueprintLibrary::GetMapDevStatus(const struct FMapEntryData& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "GetMapDevStatus");

	Params::ForeverWinterBlueprintLibrary_GetMapDevStatus Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.IsDemoBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::IsDemoBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "IsDemoBuild");

	Params::ForeverWinterBlueprintLibrary_IsDemoBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.IsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::IsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "IsShippingBuild");

	Params::ForeverWinterBlueprintLibrary_IsShippingBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.MapIsShown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMapEntryData&             Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::MapIsShown(const struct FMapEntryData& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "MapIsShown");

	Params::ForeverWinterBlueprintLibrary_MapIsShown Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.MapIsUnlocked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMapEntryData&             Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::MapIsUnlocked(const struct FMapEntryData& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "MapIsUnlocked");

	Params::ForeverWinterBlueprintLibrary_MapIsUnlocked Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.PlaySoundIfAudible
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  InAudioComp                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       InSetSound                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForeverWinterBlueprintLibrary::PlaySoundIfAudible(class UAudioComponent* InAudioComp, class USoundBase* InSetSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "PlaySoundIfAudible");

	Params::ForeverWinterBlueprintLibrary_PlaySoundIfAudible Parms{};

	Parms.InAudioComp = InAudioComp;
	Parms.InSetSound = InSetSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.PSOBackgroundCompile
// (Final, Native, Static, Public, BlueprintCallable)

void UForeverWinterBlueprintLibrary::PSOBackgroundCompile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "PSOBackgroundCompile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.PSOPrecompile
// (Final, Native, Static, Public, BlueprintCallable)

void UForeverWinterBlueprintLibrary::PSOPrecompile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "PSOPrecompile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.QuestIsUnlocked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FQuestData&                QuestData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::QuestIsUnlocked(const struct FQuestData& QuestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "QuestIsUnlocked");

	Params::ForeverWinterBlueprintLibrary_QuestIsUnlocked Parms{};

	Parms.QuestData = std::move(QuestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.Ragdoll_TEMP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForeverWinterBlueprintLibrary::Ragdoll_TEMP(class UPrimitiveComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "Ragdoll_TEMP");

	Params::ForeverWinterBlueprintLibrary_Ragdoll_TEMP Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.RoundFloat2Pos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UForeverWinterBlueprintLibrary::RoundFloat2Pos(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "RoundFloat2Pos");

	Params::ForeverWinterBlueprintLibrary_RoundFloat2Pos Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterBlueprintLibrary.SpawnImpactEffect_TEMP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FImpactEffects&            ImpactEffect                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UForeverWinterBlueprintLibrary::SpawnImpactEffect_TEMP(const struct FHitResult& HitResult, const struct FImpactEffects& ImpactEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterBlueprintLibrary", "SpawnImpactEffect_TEMP");

	Params::ForeverWinterBlueprintLibrary_SpawnImpactEffect_TEMP Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.ImpactEffect = std::move(ImpactEffect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SNameplateWidget.GetIsFriendly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USNameplateWidget::GetIsFriendly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SNameplateWidget", "GetIsFriendly");

	Params::SNameplateWidget_GetIsFriendly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ForeverWinterSettings.GetAllPlayableCharacterDefinitions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<struct FGameplayTag, struct FSoftObjectPath>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, struct FSoftObjectPath> UForeverWinterSettings::GetAllPlayableCharacterDefinitions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ForeverWinterSettings", "GetAllPlayableCharacterDefinitions");

	Params::ForeverWinterSettings_GetAllPlayableCharacterDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.GoreCollisionGameplayLibrary.FindCollisionMaterialFromHit
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   UVChannel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  MaterialIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGoreCollisionGameplayLibrary::FindCollisionMaterialFromHit(const struct FHitResult& Hit, int32 UVChannel, int32* MaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GoreCollisionGameplayLibrary", "FindCollisionMaterialFromHit");

	Params::GoreCollisionGameplayLibrary_FindCollisionMaterialFromHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.UVChannel = UVChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MaterialIndex != nullptr)
		*MaterialIndex = Parms.MaterialIndex;

	return Parms.ReturnValue;
}


// Function ForeverWinter.GoreCollisionGameplayLibrary.FindCollisionUVFromHit
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   UVChannel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       UV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGoreCollisionGameplayLibrary::FindCollisionUVFromHit(const struct FHitResult& Hit, int32 UVChannel, struct FVector2D* UV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GoreCollisionGameplayLibrary", "FindCollisionUVFromHit");

	Params::GoreCollisionGameplayLibrary_FindCollisionUVFromHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.UVChannel = UVChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (UV != nullptr)
		*UV = std::move(Parms.UV);

	return Parms.ReturnValue;
}


// Function ForeverWinter.GoreCollisionGameplayLibrary.GetHitResultPointInRefPose
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         Point                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGoreCollisionGameplayLibrary::GetHitResultPointInRefPose(const struct FHitResult& HitResult, struct FVector* Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GoreCollisionGameplayLibrary", "GetHitResultPointInRefPose");

	Params::GoreCollisionGameplayLibrary_GetHitResultPointInRefPose Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Point != nullptr)
		*Point = std::move(Parms.Point);

	return Parms.ReturnValue;
}


// Function ForeverWinter.GoreCollisionGameplayLibrary.GetSkeletalMeshRefPose
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BoneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UGoreCollisionGameplayLibrary::GetSkeletalMeshRefPose(class USkeletalMesh* SkeletalMesh, int32 BoneIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GoreCollisionGameplayLibrary", "GetSkeletalMeshRefPose");

	Params::GoreCollisionGameplayLibrary_GetSkeletalMeshRefPose Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.BoneIndex = BoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWLockPuzzle.ClosePuzzleWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InDelay                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWLockPuzzle::ClosePuzzleWidget(const float InDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "ClosePuzzleWidget");

	Params::FWLockPuzzle_ClosePuzzleWidget Parms{};

	Parms.InDelay = InDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.Lockout
// (Final, Native, Public, BlueprintCallable)

void UFWLockPuzzle::Lockout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "Lockout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.OnOwnerAliveChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsAlive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWLockPuzzle::OnOwnerAliveChanged(bool bIsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "OnOwnerAliveChanged");

	Params::FWLockPuzzle_OnOwnerAliveChanged Parms{};

	Parms.bIsAlive = bIsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.OnPuzzleIncorrect
// (Native, Event, Public, BlueprintEvent)

void UFWLockPuzzle::OnPuzzleIncorrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "OnPuzzleIncorrect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.OnPuzzleRetriesExhausted
// (Native, Event, Public, BlueprintEvent)

void UFWLockPuzzle::OnPuzzleRetriesExhausted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "OnPuzzleRetriesExhausted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.OnPuzzleSolved
// (Native, Event, Public, BlueprintEvent)

void UFWLockPuzzle::OnPuzzleSolved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "OnPuzzleSolved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.OnPuzzleTimeout
// (Native, Event, Public, BlueprintEvent)

void UFWLockPuzzle::OnPuzzleTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "OnPuzzleTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.Restart
// (Final, Native, Public, BlueprintCallable)

void UFWLockPuzzle::Restart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "Restart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.SetPuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFWLockPuzzleDefinition*          NewPuzzle                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWLockPuzzle::SetPuzzle(class UFWLockPuzzleDefinition* NewPuzzle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "SetPuzzle");

	Params::FWLockPuzzle_SetPuzzle Parms{};

	Parms.NewPuzzle = NewPuzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzle.GetAttemptsRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWLockPuzzle::GetAttemptsRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "GetAttemptsRemaining");

	Params::FWLockPuzzle_GetAttemptsRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWLockPuzzle.GetTimeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWLockPuzzle::GetTimeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzle", "GetTimeRemaining");

	Params::FWLockPuzzle_GetTimeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameState.OnFactionRelationshipChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              FromFactionTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ToFactionTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              RelationshipTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameState::OnFactionRelationshipChanged(const struct FGameplayTag& FromFactionTag, const struct FGameplayTag& ToFactionTag, const struct FGameplayTag& RelationshipTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "OnFactionRelationshipChanged");

	Params::FWGameState_OnFactionRelationshipChanged Parms{};

	Parms.FromFactionTag = std::move(FromFactionTag);
	Parms.ToFactionTag = std::move(ToFactionTag);
	Parms.RelationshipTag = std::move(RelationshipTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.OnFactionRelationshipsReset
// (Final, Native, Protected)

void AFWGameState::OnFactionRelationshipsReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "OnFactionRelationshipsReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.OnRep_CountOfAITargettingAnyPlayer
// (Final, Native, Protected)

void AFWGameState::OnRep_CountOfAITargettingAnyPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "OnRep_CountOfAITargettingAnyPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.OnRep_GameOver
// (Final, Native, Protected)

void AFWGameState::OnRep_GameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "OnRep_GameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.OnRep_RelationshipReceived
// (Final, Native, Protected)

void AFWGameState::OnRep_RelationshipReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "OnRep_RelationshipReceived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.OnRep_ReturningToHub
// (Final, Native, Protected)

void AFWGameState::OnRep_ReturningToHub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "OnRep_ReturningToHub");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.StartReturnToHub
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TimePeriod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameState::StartReturnToHub(int32 TimePeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "StartReturnToHub");

	Params::FWGameState_StartReturnToHub Parms{};

	Parms.TimePeriod = TimePeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameState.GetGameOverState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameState::GetGameOverState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "GetGameOverState");

	Params::FWGameState_GetGameOverState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameState.GetHubReturnTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AFWGameState::GetHubReturnTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "GetHubReturnTimer");

	Params::FWGameState_GetHubReturnTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameState.GetMaxPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AFWGameState::GetMaxPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameState", "GetMaxPlayerCount");

	Params::FWGameState_GetMaxPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWPlayerAnimInstance.EnableRootMotionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWPlayerAnimInstance::EnableRootMotionMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWPlayerAnimInstance", "EnableRootMotionMode");

	Params::FWPlayerAnimInstance_EnableRootMotionMode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigameHazzard.OnOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFWMinigameHazzard::OnOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigameHazzard", "OnOverlap");

	Params::FWMinigameHazzard_OnOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIEscapeLibrary.FreeAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ThePawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWAIEscapeLibrary::FreeAI(class AActor* Instigator, class APawn* ThePawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIEscapeLibrary", "FreeAI");

	Params::FWAIEscapeLibrary_FreeAI Parms{};

	Parms.Instigator = Instigator;
	Parms.ThePawn = ThePawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.AbortMeleeAttack
// (Native, Public, BlueprintCallable)

void AFWGameCharacter::AbortMeleeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "AbortMeleeAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ApplyHitExtras
// (Native, Event, Protected, BlueprintEvent)

void AFWGameCharacter::ApplyHitExtras()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ApplyHitExtras");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ArmMeleeLimbsTimer
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EMeleeLimb                              Limbs                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArmIn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisarmAfter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ArmMeleeLimbsTimer(EMeleeLimb Limbs, float ArmIn, float DisarmAfter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ArmMeleeLimbsTimer");

	Params::FWGameCharacter_ArmMeleeLimbsTimer Parms{};

	Parms.Limbs = Limbs;
	Parms.ArmIn = ArmIn;
	Parms.DisarmAfter = DisarmAfter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.BoneToImpactArea
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImpactArea                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EImpactArea AFWGameCharacter::BoneToImpactArea(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "BoneToImpactArea");

	Params::FWGameCharacter_BoneToImpactArea Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.CauseMeleeDamage
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           ApparentTarget                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::CauseMeleeDamage(class AActor* ApparentTarget, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "CauseMeleeDamage");

	Params::FWGameCharacter_CauseMeleeDamage Parms{};

	Parms.ApparentTarget = ApparentTarget;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.ClientPlayLensFX
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class UParticleSystem*                  FX                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ClientPlayLensFX(class UParticleSystem* FX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ClientPlayLensFX");

	Params::FWGameCharacter_ClientPlayLensFX Parms{};

	Parms.FX = FX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.DropAllWeapons
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AFWGameCharacter::DropAllWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "DropAllWeapons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGameCharacter.GetBattlePoint
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetBattlePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetBattlePoint");

	Params::FWGameCharacter_GetBattlePoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetBattlePointDamagePerHP
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetBattlePointDamagePerHP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetBattlePointDamagePerHP");

	Params::FWGameCharacter_GetBattlePointDamagePerHP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetBattlePointDamagePerKill
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetBattlePointDamagePerKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetBattlePointDamagePerKill");

	Params::FWGameCharacter_GetBattlePointDamagePerKill Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetCurrentWeapon
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IAgentWeapon>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IAgentWeapon> AFWGameCharacter::GetCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetCurrentWeapon");

	Params::FWGameCharacter_GetCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.HandleHealthChanged
// (Final, Native, Private)
// Parameters:
// class UFWHealthComponent*               HealthComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::HandleHealthChanged(class UFWHealthComponent* HealthComponent, float OldHealth, float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "HandleHealthChanged");

	Params::FWGameCharacter_HandleHealthChanged Parms{};

	Parms.HealthComponent = HealthComponent;
	Parms.OldHealth = OldHealth;
	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.HandleMaxHealthChanged
// (Final, Native, Private)
// Parameters:
// class UFWHealthComponent*               HealthComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::HandleMaxHealthChanged(class UFWHealthComponent* HealthComponent, float OldHealth, float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "HandleMaxHealthChanged");

	Params::FWGameCharacter_HandleMaxHealthChanged Parms{};

	Parms.HealthComponent = HealthComponent;
	Parms.OldHealth = OldHealth;
	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.LootableContainer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASInventoryContainer*             Container                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::LootableContainer(class ASInventoryContainer* Container, bool InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "LootableContainer");

	Params::FWGameCharacter_LootableContainer Parms{};

	Parms.Container = Container;
	Parms.InRange = InRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.MeleeAttack
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::MeleeAttack(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "MeleeAttack");

	Params::FWGameCharacter_MeleeAttack Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ModifyBattlePoint
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentBattlePoint                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxBattlePoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BattlePointThreshold                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ModifyBattlePoint(float CurrentBattlePoint, float MaxBattlePoint, float BattlePointThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ModifyBattlePoint");

	Params::FWGameCharacter_ModifyBattlePoint Parms{};

	Parms.CurrentBattlePoint = CurrentBattlePoint;
	Parms.MaxBattlePoint = MaxBattlePoint;
	Parms.BattlePointThreshold = BattlePointThreshold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGameCharacter.OnAbortMeleeAttack
// (Event, Protected, BlueprintEvent)

void AFWGameCharacter::OnAbortMeleeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "OnAbortMeleeAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGameCharacter.OnMeleeAttack
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::OnMeleeAttack(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "OnMeleeAttack");

	Params::FWGameCharacter_OnMeleeAttack Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGameCharacter.OnRep_LastMeleeAttackInfo
// (Final, Native, Protected)

void AFWGameCharacter::OnRep_LastMeleeAttackInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "OnRep_LastMeleeAttackInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.OnRep_LastTakeHitInfo
// (Final, Native, Protected)

void AFWGameCharacter::OnRep_LastTakeHitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "OnRep_LastTakeHitInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.OnRep_TraversalData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTraversalData&            OldTraversalData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AFWGameCharacter::OnRep_TraversalData(const struct FTraversalData& OldTraversalData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "OnRep_TraversalData");

	Params::FWGameCharacter_OnRep_TraversalData Parms{};

	Parms.OldTraversalData = std::move(OldTraversalData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.OnWeaponMeleeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TSubclassOf<class UDamageType>          DamageType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFWGameCharacter::OnWeaponMeleeDamage(TSubclassOf<class UDamageType> DamageType, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "OnWeaponMeleeDamage");

	Params::FWGameCharacter_OnWeaponMeleeDamage Parms{};

	Parms.DamageType = DamageType;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.RemoveMeleeTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ApparentTarget                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::RemoveMeleeTarget(class AActor* ApparentTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "RemoveMeleeTarget");

	Params::FWGameCharacter_RemoveMeleeTarget Parms{};

	Parms.ApparentTarget = ApparentTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.ResetCanFire
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AFWGameCharacter::ResetCanFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ResetCanFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.RestoreFromRagdoll
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   SpineDir                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::RestoreFromRagdoll(const struct FVector& SpineDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "RestoreFromRagdoll");

	Params::FWGameCharacter_RestoreFromRagdoll Parms{};

	Parms.SpineDir = std::move(SpineDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ServerDie
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// const struct FDamageEvent&              DamageEvent                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ServerDie(const struct FDamageEvent& DamageEvent, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ServerDie");

	Params::FWGameCharacter_ServerDie Parms{};

	Parms.DamageEvent = std::move(DamageEvent);
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ServerMeleeAttack
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ServerMeleeAttack(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ServerMeleeAttack");

	Params::FWGameCharacter_ServerMeleeAttack Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ServerSetIsJumping
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    NewJumping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ServerSetIsJumping(bool NewJumping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ServerSetIsJumping");

	Params::FWGameCharacter_ServerSetIsJumping Parms{};

	Parms.NewJumping = NewJumping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.ServerSetSprinting
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    NewSprinting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::ServerSetSprinting(bool NewSprinting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "ServerSetSprinting");

	Params::FWGameCharacter_ServerSetSprinting Parms{};

	Parms.NewSprinting = NewSprinting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.SetAgentIsAiming
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::SetAgentIsAiming(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "SetAgentIsAiming");

	Params::FWGameCharacter_SetAgentIsAiming Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.SetAgentIsInCover
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewIsInCover                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::SetAgentIsInCover(bool NewIsInCover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "SetAgentIsInCover");

	Params::FWGameCharacter_SetAgentIsInCover Parms{};

	Parms.NewIsInCover = NewIsInCover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.SetControlRotation
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  NewControlRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AFWGameCharacter::SetControlRotation(const struct FRotator& NewControlRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "SetControlRotation");

	Params::FWGameCharacter_SetControlRotation Parms{};

	Parms.NewControlRotation = std::move(NewControlRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.SetIsAiming
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::SetIsAiming(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "SetIsAiming");

	Params::FWGameCharacter_SetIsAiming Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGameCharacter.SetIsFiring
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::SetIsFiring(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "SetIsFiring");

	Params::FWGameCharacter_SetIsFiring Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGameCharacter.SetSyncAnimationVictim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameCharacter::SetSyncAnimationVictim(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "SetSyncAnimationVictim");

	Params::FWGameCharacter_SetSyncAnimationVictim Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.UpdateCanLoot
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void AFWGameCharacter::UpdateCanLoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "UpdateCanLoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameCharacter.CanFire
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::CanFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "CanFire");

	Params::FWGameCharacter_CanFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.CanStartAction
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::CanStartAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "CanStartAction");

	Params::FWGameCharacter_CanStartAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetAgentHasCoverAvailable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::GetAgentHasCoverAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetAgentHasCoverAvailable");

	Params::FWGameCharacter_GetAgentHasCoverAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetAgentIsAiming
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::GetAgentIsAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetAgentIsAiming");

	Params::FWGameCharacter_GetAgentIsAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetAgentIsFiring
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::GetAgentIsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetAgentIsFiring");

	Params::FWGameCharacter_GetAgentIsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetAgentIsInCover
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::GetAgentIsInCover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetAgentIsInCover");

	Params::FWGameCharacter_GetAgentIsInCover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetHealth");

	Params::FWGameCharacter_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetHealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetHealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetHealthRatio");

	Params::FWGameCharacter_GetHealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetIsFiring
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::GetIsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetIsFiring");

	Params::FWGameCharacter_GetIsFiring Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetMaxHealth");

	Params::FWGameCharacter_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetMotionState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EA_MotionState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EA_MotionState AFWGameCharacter::GetMotionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetMotionState");

	Params::FWGameCharacter_GetMotionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetReloadSpeedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGameCharacter::GetReloadSpeedMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetReloadSpeedMultiplier");

	Params::FWGameCharacter_GetReloadSpeedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetSyncAnimationVictim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AFWGameCharacter::GetSyncAnimationVictim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetSyncAnimationVictim");

	Params::FWGameCharacter_GetSyncAnimationVictim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.GetTraversalType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EA_TraversalType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EA_TraversalType AFWGameCharacter::GetTraversalType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "GetTraversalType");

	Params::FWGameCharacter_GetTraversalType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsAlive");

	Params::FWGameCharacter_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsDeadOrDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsDeadOrDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsDeadOrDown");

	Params::FWGameCharacter_IsDeadOrDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsDown");

	Params::FWGameCharacter_IsDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsFiring");

	Params::FWGameCharacter_IsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsInitiatedJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsInitiatedJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsInitiatedJump");

	Params::FWGameCharacter_IsInitiatedJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsInMeleeAttack
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsInMeleeAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsInMeleeAttack");

	Params::FWGameCharacter_IsInMeleeAttack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameCharacter.IsSprinting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameCharacter::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameCharacter", "IsSprinting");

	Params::FWGameCharacter_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameAICharacter.GetAgentCharacter
// (Native, Protected, BlueprintCallable)
// Parameters:
// TScriptInterface<class IAgentCharacter> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IAgentCharacter> AFWGameAICharacter::GetAgentCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameAICharacter", "GetAgentCharacter");

	Params::FWGameAICharacter_GetAgentCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameAICharacter.GetLooted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGameAICharacter::GetLooted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameAICharacter", "GetLooted");

	Params::FWGameAICharacter_GetLooted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameAICharacter.GetAIEyesViewPoint
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AFWGameAICharacter::GetAIEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameAICharacter", "GetAIEyesViewPoint");

	Params::FWGameAICharacter_GetAIEyesViewPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function ForeverWinter.FWMinigameScenarioSpawner.EndScenario
// (Event, Public, BlueprintEvent)

void AFWMinigameScenarioSpawner::EndScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigameScenarioSpawner", "EndScenario");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWMinigameScenarioSpawner.SpawnScenario
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFWMinigamePlayerPawn*            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWMinigameScenarioSpawner::SpawnScenario(class AFWMinigamePlayerPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigameScenarioSpawner", "SpawnScenario");

	Params::FWMinigameScenarioSpawner_SpawnScenario Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.SendAwarenessReactionAbilityEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFWAIAwarenessState                     FromState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFWAIAwarenessState                     ToState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWAIGA_AwarenessReaction::SendAwarenessReactionAbilityEvent(class AActor* Target, const struct FGameplayTag& EventTag, EFWAIAwarenessState FromState, EFWAIAwarenessState ToState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWAIGA_AwarenessReaction", "SendAwarenessReactionAbilityEvent");

	Params::FWAIGA_AwarenessReaction_SendAwarenessReactionAbilityEvent Parms{};

	Parms.Target = Target;
	Parms.EventTag = std::move(EventTag);
	Parms.FromState = FromState;
	Parms.ToState = ToState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.CreatePlayMontageAndWaitProxy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     InMontageToPlay                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRootMotionTranslationScale                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTimeSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlayMontageAndWait*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlayMontageAndWait* UFWAIGA_AwarenessReaction::CreatePlayMontageAndWaitProxy(class FName TaskInstanceName, class UAnimMontage* InMontageToPlay, float Rate, class FName StartSection, bool bStopWhenAbilityEnds, float AnimRootMotionTranslationScale, float StartTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "CreatePlayMontageAndWaitProxy");

	Params::FWAIGA_AwarenessReaction_CreatePlayMontageAndWaitProxy Parms{};

	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InMontageToPlay = InMontageToPlay;
	Parms.Rate = Rate;
	Parms.StartSection = StartSection;
	Parms.bStopWhenAbilityEnds = bStopWhenAbilityEnds;
	Parms.AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;
	Parms.StartTimeSeconds = StartTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.K2_OnBlendOut
// (Event, Public, BlueprintEvent)

void UFWAIGA_AwarenessReaction::K2_OnBlendOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "K2_OnBlendOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.K2_OnCancelled
// (Event, Public, BlueprintEvent)

void UFWAIGA_AwarenessReaction::K2_OnCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "K2_OnCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.K2_OnCompleted
// (Event, Public, BlueprintEvent)

void UFWAIGA_AwarenessReaction::K2_OnCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "K2_OnCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.K2_OnInterrupted
// (Event, Public, BlueprintEvent)

void UFWAIGA_AwarenessReaction::K2_OnInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "K2_OnInterrupted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.OnBlendOut
// (Native, Public)

void UFWAIGA_AwarenessReaction::OnBlendOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "OnBlendOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.OnCancelled
// (Native, Public)

void UFWAIGA_AwarenessReaction::OnCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "OnCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.OnCompleted
// (Native, Public)

void UFWAIGA_AwarenessReaction::OnCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "OnCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.OnInterrupted
// (Native, Public)

void UFWAIGA_AwarenessReaction::OnInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "OnInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.OnNotifyBeginReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFWAIGA_AwarenessReaction::OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "OnNotifyBeginReceived");

	Params::FWAIGA_AwarenessReaction_OnNotifyBeginReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.OnNotifyEndReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFWAIGA_AwarenessReaction::OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "OnNotifyEndReceived");

	Params::FWAIGA_AwarenessReaction_OnNotifyEndReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIGA_AwarenessReaction.PlayMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StartSection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlayMontageAndWait*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlayMontageAndWait* UFWAIGA_AwarenessReaction::PlayMontage(class FName StartSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIGA_AwarenessReaction", "PlayMontage");

	Params::FWAIGA_AwarenessReaction_PlayMontage Parms{};

	Parms.StartSection = StartSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWAIManeuverService.CallManeuver
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AAIController*              Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UFWAIManeuverService::CallManeuver(const class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWAIManeuverService", "CallManeuver");

	Params::FWAIManeuverService_CallManeuver Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFCTWidget.TakeDamage
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// int32                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ImpactLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrecisionHit                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USFCTWidget::TakeDamage(int32 DamageAmount, const struct FVector& ImpactLocation, bool bPrecisionHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SFCTWidget", "TakeDamage");

	Params::SFCTWidget_TakeDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.ImpactLocation = std::move(ImpactLocation);
	Parms.bPrecisionHit = bPrecisionHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWAIMechCharacter.DefaultArmorDamagedHandler
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWAIMechCharacter::DefaultArmorDamagedHandler(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechCharacter", "DefaultArmorDamagedHandler");

	Params::FWAIMechCharacter_DefaultArmorDamagedHandler Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechCharacter.DefaultCriticalHitHandler
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWAIMechCharacter::DefaultCriticalHitHandler(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechCharacter", "DefaultCriticalHitHandler");

	Params::FWAIMechCharacter_DefaultCriticalHitHandler Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechCharacter.GetPrimaryAimOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AFWAIMechCharacter::GetPrimaryAimOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechCharacter", "GetPrimaryAimOffset");

	Params::FWAIMechCharacter_GetPrimaryAimOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWAIMechCharacter.RegisterArmorHitListeners
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechCharacter::RegisterArmorHitListeners()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechCharacter", "RegisterArmorHitListeners");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechCharacter.TurnActionComplete
// (Final, Native, Public, BlueprintCallable)

void AFWAIMechCharacter::TurnActionComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechCharacter", "TurnActionComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.DefaultArmorDamagedHandler
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWAIMechWeapon::DefaultArmorDamagedHandler(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "DefaultArmorDamagedHandler");

	Params::FWAIMechWeapon_DefaultArmorDamagedHandler Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.DefaultCriticalHitHandler
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWAIMechWeapon::DefaultCriticalHitHandler(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "DefaultCriticalHitHandler");

	Params::FWAIMechWeapon_DefaultCriticalHitHandler Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.DefaultDetachmentHandler
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechWeapon::DefaultDetachmentHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "DefaultDetachmentHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.MakeLootable
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechWeapon::MakeLootable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "MakeLootable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.OnDamageWeapon
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechWeapon::OnDamageWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "OnDamageWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.OnDetachWeapon
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechWeapon::OnDetachWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "OnDetachWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.OnDisableWeapon
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechWeapon::OnDisableWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "OnDisableWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.OnRep_Hitpoints
// (Final, Native, Public)

void AFWAIMechWeapon::OnRep_Hitpoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "OnRep_Hitpoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.RegisterArmorHitListeners
// (Native, Event, Protected, BlueprintEvent)

void AFWAIMechWeapon::RegisterArmorHitListeners()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "RegisterArmorHitListeners");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMechWeapon.SetAimYawAndPitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWAIMechWeapon::SetAimYawAndPitch(float NewYaw, float NewPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMechWeapon", "SetAimYawAndPitch");

	Params::FWAIMechWeapon_SetAimYawAndPitch Parms{};

	Parms.NewYaw = NewYaw;
	Parms.NewPitch = NewPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIMeleeService.OnMelee
// (Final, Native, Protected)

void UFWAIMeleeService::OnMelee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIMeleeService", "OnMelee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIRecruitTargetService.OnOwnerWeaponFired
// (Final, Native, Protected)

void UFWAIRecruitTargetService::OnOwnerWeaponFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIRecruitTargetService", "OnOwnerWeaponFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAIRecruitTargetService.OwnerTookDamage
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDamageType*                DamageType                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWAIRecruitTargetService::OwnerTookDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAIRecruitTargetService", "OwnerTookDamage");

	Params::FWAIRecruitTargetService_OwnerTookDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWArmorContainerComponent.BreakOffComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWArmorContainerComponent::BreakOffComponent(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWArmorContainerComponent", "BreakOffComponent");

	Params::FWArmorContainerComponent_BreakOffComponent Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWArmorContainerComponent.Explode
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWArmorContainerComponent::Explode(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWArmorContainerComponent", "Explode");

	Params::FWArmorContainerComponent_Explode Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAsyncTaskCooldownChanged.ListenForCooldownChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     CooldownTags                                           (Parm, NativeAccessSpecifierPublic)
// class UFWAsyncTaskCooldownChanged*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFWAsyncTaskCooldownChanged* UFWAsyncTaskCooldownChanged::ListenForCooldownChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTagContainer& CooldownTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWAsyncTaskCooldownChanged", "ListenForCooldownChange");

	Params::FWAsyncTaskCooldownChanged_ListenForCooldownChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.CooldownTags = std::move(CooldownTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWAsyncTaskCooldownChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UFWAsyncTaskCooldownChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAsyncTaskCooldownChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent_0                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWAsyncTaskEffectStackChanged*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFWAsyncTaskEffectStackChanged* UFWAsyncTaskEffectStackChanged::ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent_0, const struct FGameplayTag& EffectGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWAsyncTaskEffectStackChanged", "ListenForGameplayEffectStackChange");

	Params::FWAsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange Parms{};

	Parms.AbilitySystemComponent_0 = AbilitySystemComponent_0;
	Parms.EffectGameplayTag = std::move(EffectGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWAsyncTaskEffectStackChanged.EndListenForGameplayEffectStackChangeTask
// (Final, Native, Public, BlueprintCallable)

void UFWAsyncTaskEffectStackChanged::EndListenForGameplayEffectStackChangeTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAsyncTaskEffectStackChanged", "EndListenForGameplayEffectStackChangeTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAudioVolume.HandleListenerEnterEvent
// (Final, Native, Protected)

void AFWAudioVolume::HandleListenerEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAudioVolume", "HandleListenerEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAudioVolume.HandleListenerExitEvent
// (Final, Native, Protected)

void AFWAudioVolume::HandleListenerExitEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAudioVolume", "HandleListenerExitEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAwarenessWidgetComponent.UpdateLOSIgnoreList
// (Final, Native, Public, BlueprintCallable)

void UFWAwarenessWidgetComponent::UpdateLOSIgnoreList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAwarenessWidgetComponent", "UpdateLOSIgnoreList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWAwarenessWidgetComponent.GetLineOfSightIgnoreList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>*                  OutList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFWAwarenessWidgetComponent::GetLineOfSightIgnoreList(TArray<class AActor*>* OutList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAwarenessWidgetComponent", "GetLineOfSightIgnoreList");

	Params::FWAwarenessWidgetComponent_GetLineOfSightIgnoreList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);
}


// Function ForeverWinter.FWBarPatron.GetCurrentLoyalty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWBarPatron::GetCurrentLoyalty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarPatron", "GetCurrentLoyalty");

	Params::FWBarPatron_GetCurrentLoyalty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWBarPatron.GetVisited
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWBarPatron::GetVisited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarPatron", "GetVisited");

	Params::FWBarPatron_GetVisited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWBarPatron.UpdateVisited
// (Final, Native, Public, BlueprintCallable)

void UFWBarPatron::UpdateVisited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWBarPatron", "UpdateVisited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWCommonActionUserWidget.GetKeySize
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UFWCommonActionUserWidget::GetKeySize(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWCommonActionUserWidget", "GetKeySize");

	Params::FWCommonActionUserWidget_GetKeySize Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWCommonActionUserWidget.GetKeyText
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFWCommonActionUserWidget::GetKeyText(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWCommonActionUserWidget", "GetKeyText");

	Params::FWCommonActionUserWidget_GetKeyText Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWCommonActionUserWidget.OnInputMethodChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bUsingGamepad                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWCommonActionUserWidget::OnInputMethodChanged(bool bUsingGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWCommonActionUserWidget", "OnInputMethodChanged");

	Params::FWCommonActionUserWidget_OnInputMethodChanged Parms{};

	Parms.bUsingGamepad = bUsingGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWCommonActionUserWidget.SetEnhancedInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InInputAction                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWCommonActionUserWidget::SetEnhancedInputAction(class UInputAction* InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWCommonActionUserWidget", "SetEnhancedInputAction");

	Params::FWCommonActionUserWidget_SetEnhancedInputAction Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWCommonActionUserWidget.UpdateKey
// (Final, Native, Public, BlueprintCallable)

void UFWCommonActionUserWidget::UpdateKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWCommonActionUserWidget", "UpdateKey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWDailyGiftList.GetRandomItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UFWDailyGiftList::GetRandomItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWDailyGiftList", "GetRandomItem");

	Params::FWDailyGiftList_GetRandomItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWDeployableActorPlacement.CanPlaceDeployable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWDeployableActorPlacement::CanPlaceDeployable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWDeployableActorPlacement", "CanPlaceDeployable");

	Params::FWDeployableActorPlacement_CanPlaceDeployable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWExtraction.ServerTravel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Location                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              OverrideGameMode                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWExtraction::ServerTravel(const class FString& Map, const class FString& Location, const bool OverrideGameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWExtraction", "ServerTravel");

	Params::FWExtraction_ServerTravel Parms{};

	Parms.Map = std::move(Map);
	Parms.Location = std::move(Location);
	Parms.OverrideGameMode = OverrideGameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.ApplyFactionControlDelta
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FactionTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             DeltaPercentagePoints                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, float>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, float> UFWFactionMapControlFunctionLibrary::ApplyFactionControlDelta(class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag, const struct FGameplayTag& FactionTag, const float DeltaPercentagePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "ApplyFactionControlDelta");

	Params::FWFactionMapControlFunctionLibrary_ApplyFactionControlDelta Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);
	Parms.FactionTag = std::move(FactionTag);
	Parms.DeltaPercentagePoints = DeltaPercentagePoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.GetFactionControl
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FactionTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWFactionMapControlFunctionLibrary::GetFactionControl(const class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag, const struct FGameplayTag& FactionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "GetFactionControl");

	Params::FWFactionMapControlFunctionLibrary_GetFactionControl Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);
	Parms.FactionTag = std::move(FactionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.GetFactionControlDeltas
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, float>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, float> UFWFactionMapControlFunctionLibrary::GetFactionControlDeltas(const class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "GetFactionControlDeltas");

	Params::FWFactionMapControlFunctionLibrary_GetFactionControlDeltas Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.GetFactionControlValues
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, float>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, float> UFWFactionMapControlFunctionLibrary::GetFactionControlValues(const class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "GetFactionControlValues");

	Params::FWFactionMapControlFunctionLibrary_GetFactionControlValues Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.GetLocalPersistenceSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWPersistenceSubsystem*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFWPersistenceSubsystem* UFWFactionMapControlFunctionLibrary::GetLocalPersistenceSubsystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "GetLocalPersistenceSubsystem");

	Params::FWFactionMapControlFunctionLibrary_GetLocalPersistenceSubsystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.GetTugOfWarCurrentMapTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UFWFactionMapControlFunctionLibrary::GetTugOfWarCurrentMapTag(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "GetTugOfWarCurrentMapTag");

	Params::FWFactionMapControlFunctionLibrary_GetTugOfWarCurrentMapTag Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.HasFactionControl
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FactionTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWFactionMapControlFunctionLibrary::HasFactionControl(const class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag, const struct FGameplayTag& FactionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "HasFactionControl");

	Params::FWFactionMapControlFunctionLibrary_HasFactionControl Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);
	Parms.FactionTag = std::move(FactionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.ModifyFactionControl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FactionTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PercentagePoints                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, float>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, float> UFWFactionMapControlFunctionLibrary::ModifyFactionControl(class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag, const struct FGameplayTag& FactionTag, const float PercentagePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "ModifyFactionControl");

	Params::FWFactionMapControlFunctionLibrary_ModifyFactionControl Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);
	Parms.FactionTag = std::move(FactionTag);
	Parms.PercentagePoints = PercentagePoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.ResetAllFactionControl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWFactionMapControlFunctionLibrary::ResetAllFactionControl(class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "ResetAllFactionControl");

	Params::FWFactionMapControlFunctionLibrary_ResetAllFactionControl Parms{};

	Parms.Subsystem = Subsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.ResetFactionControl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, float>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, float> UFWFactionMapControlFunctionLibrary::ResetFactionControl(class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "ResetFactionControl");

	Params::FWFactionMapControlFunctionLibrary_ResetFactionControl Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWFactionMapControlFunctionLibrary.SetFactionControlDeltas
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeMapTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FactionTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PercentagePoints                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWFactionMapControlFunctionLibrary::SetFactionControlDeltas(class UFWPersistenceSubsystem* Subsystem, const struct FGameplayTag& ScopeMapTag, const struct FGameplayTag& FactionTag, const float PercentagePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWFactionMapControlFunctionLibrary", "SetFactionControlDeltas");

	Params::FWFactionMapControlFunctionLibrary_SetFactionControlDeltas Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ScopeMapTag = std::move(ScopeMapTag);
	Parms.FactionTag = std::move(FactionTag);
	Parms.PercentagePoints = PercentagePoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameInstanceInterface.GetDropContainer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class ASInventoryContainer> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ASInventoryContainer> IFWGameInstanceInterface::GetDropContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FWGameInstanceInterface", "GetDropContainer");

	Params::FWGameInstanceInterface_GetDropContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameInstanceInterface.GetItemClass
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> IFWGameInstanceInterface::GetItemClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FWGameInstanceInterface", "GetItemClass");

	Params::FWGameInstanceInterface_GetItemClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameInstanceInterface.GetValueOverride
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName                       RowName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FValueOverride*                  OverrideOut                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFWGameInstanceInterface::GetValueOverride(const class FName RowName, struct FValueOverride* OverrideOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FWGameInstanceInterface", "GetValueOverride");

	Params::FWGameInstanceInterface_GetValueOverride Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OverrideOut != nullptr)
		*OverrideOut = std::move(Parms.OverrideOut);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameMode_Default.OpenHub
// (Final, Native, Public, BlueprintCallable)

void AFWGameMode_Default::OpenHub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameMode_Default", "OpenHub");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameMode_Default.OpenNextMap
// (Native, Event, Protected, BlueprintEvent)

void AFWGameMode_Default::OpenNextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameMode_Default", "OpenNextMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePersistenceFunctionLibrary.FlushAccumulatedFactionScore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGamePersistenceFunctionLibrary::FlushAccumulatedFactionScore(const class UObject* WorldContextObject, class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWGamePersistenceFunctionLibrary", "FlushAccumulatedFactionScore");

	Params::FWGamePersistenceFunctionLibrary_FlushAccumulatedFactionScore Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePersistenceFunctionLibrary.ModifyFactionScore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFWCharacter*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FactionTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const double                            Delta                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGamePersistenceFunctionLibrary::ModifyFactionScore(class AFWCharacter* Player, const struct FGameplayTag& FactionTag, const double Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWGamePersistenceFunctionLibrary", "ModifyFactionScore");

	Params::FWGamePersistenceFunctionLibrary_ModifyFactionScore Parms{};

	Parms.Player = Player;
	Parms.FactionTag = std::move(FactionTag);
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePersistenceFunctionLibrary.ModifyScopedFactionScore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFWCharacter*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScopeTag                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const double                            Delta                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGamePersistenceFunctionLibrary::ModifyScopedFactionScore(class AFWCharacter* Player, const struct FGameplayTag& ScopeTag, const double Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWGamePersistenceFunctionLibrary", "ModifyScopedFactionScore");

	Params::FWGamePersistenceFunctionLibrary_ModifyScopedFactionScore Parms{};

	Parms.Player = Player;
	Parms.ScopeTag = std::move(ScopeTag);
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ActiveEquipmentUpdated
// (Native, Event, Public, BlueprintEvent)

void AFWGamePlayerCharacter::ActiveEquipmentUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ActiveEquipmentUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.AreWeIn1P_ADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::AreWeIn1P_ADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "AreWeIn1P_ADS");

	Params::FWGamePlayerCharacter_AreWeIn1P_ADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.AreWeIn3P_ADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::AreWeIn3P_ADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "AreWeIn3P_ADS");

	Params::FWGamePlayerCharacter_AreWeIn3P_ADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.BeginCameraLerpThrowable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDirection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::BeginCameraLerpThrowable(bool bDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "BeginCameraLerpThrowable");

	Params::FWGamePlayerCharacter_BeginCameraLerpThrowable Parms{};

	Parms.bDirection = bDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.BodyLooted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   AmmoCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::BodyLooted(int32 AmmoCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "BodyLooted");

	Params::FWGamePlayerCharacter_BodyLooted Parms{};

	Parms.AmmoCount = AmmoCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.CanContainerFit
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FInventoryItemDetails&     ItemDetails                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             StackCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::CanContainerFit(const struct FInventoryItemDetails& ItemDetails, const int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "CanContainerFit");

	Params::FWGamePlayerCharacter_CanContainerFit Parms{};

	Parms.ItemDetails = std::move(ItemDetails);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.ChangeSelectedContainerItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Next                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ChangeSelectedContainerItem(bool Next)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ChangeSelectedContainerItem");

	Params::FWGamePlayerCharacter_ChangeSelectedContainerItem Parms{};

	Parms.Next = Next;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.CharacterCanLootPrompt
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    LootTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanLootTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELootFailerReason                       FailReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SwapActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::CharacterCanLootPrompt(bool LootTarget, bool CanLootTarget, ELootFailerReason FailReason, class AActor* HitActor, class AActor* SwapActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "CharacterCanLootPrompt");

	Params::FWGamePlayerCharacter_CharacterCanLootPrompt Parms{};

	Parms.LootTarget = LootTarget;
	Parms.CanLootTarget = CanLootTarget;
	Parms.FailReason = FailReason;
	Parms.HitActor = HitActor;
	Parms.SwapActor = SwapActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientBodyLooted
// (Net, NetReliable, Native, Event, Protected, NetClient, BlueprintCallable)
// Parameters:
// int32                                   AmmoCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ClientBodyLooted(int32 AmmoCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientBodyLooted");

	Params::FWGamePlayerCharacter_ClientBodyLooted Parms{};

	Parms.AmmoCount = AmmoCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientCrabBotInventory
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class UFWCrabBotInventory*              CrabBotInventory                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWRigContainersComponent*        RelevantContainer                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWMultiRigDanglySlot*            RelevantMultiDangly                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ClientCrabBotInventory(class UFWCrabBotInventory* CrabBotInventory, class UFWRigContainersComponent* RelevantContainer, class UFWMultiRigDanglySlot* RelevantMultiDangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientCrabBotInventory");

	Params::FWGamePlayerCharacter_ClientCrabBotInventory Parms{};

	Parms.CrabBotInventory = CrabBotInventory;
	Parms.RelevantContainer = RelevantContainer;
	Parms.RelevantMultiDangly = RelevantMultiDangly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientFailedToOpenContainer
// (Net, NetReliable, Native, Event, Public, NetClient)

void AFWGamePlayerCharacter::ClientFailedToOpenContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientFailedToOpenContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientLootFailure
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// ELootFailerReason                       FailReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ClientLootFailure(ELootFailerReason FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientLootFailure");

	Params::FWGamePlayerCharacter_ClientLootFailure Parms{};

	Parms.FailReason = FailReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientOpenContainer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ASInventoryContainer*             Container                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ClientOpenContainer(class ASInventoryContainer* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientOpenContainer");

	Params::FWGamePlayerCharacter_ClientOpenContainer Parms{};

	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientOpenCrabBot
// (Net, NetReliable, Native, Event, Public, NetClient)

void AFWGamePlayerCharacter::ClientOpenCrabBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientOpenCrabBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientStartMounting
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    MountingWeapon                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USceneComponent*            MountingComponent                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinYawRotationRange                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxYawRotationRange                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinPitchRotationRange                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxPitchRotationRange                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ClientStartMounting(class AFWWeaponBase* MountingWeapon, const class USceneComponent* MountingComponent, const float MinYawRotationRange, const float MaxYawRotationRange, const float MinPitchRotationRange, const float MaxPitchRotationRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientStartMounting");

	Params::FWGamePlayerCharacter_ClientStartMounting Parms{};

	Parms.MountingWeapon = MountingWeapon;
	Parms.MountingComponent = MountingComponent;
	Parms.MinYawRotationRange = MinYawRotationRange;
	Parms.MaxYawRotationRange = MaxYawRotationRange;
	Parms.MinPitchRotationRange = MinPitchRotationRange;
	Parms.MaxPitchRotationRange = MaxPitchRotationRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientStopLooting
// (Net, NetReliable, Native, Event, Protected, NetClient)

void AFWGamePlayerCharacter::ClientStopLooting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientStopLooting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientStopMounting
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void AFWGamePlayerCharacter::ClientStopMounting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientStopMounting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ClientValidateLootables
// (Net, NetReliable, Native, Event, Public, NetClient)

void AFWGamePlayerCharacter::ClientValidateLootables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ClientValidateLootables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.CycleAmmoType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    WeaponToCycle                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::CycleAmmoType(class AFWWeaponBase* WeaponToCycle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "CycleAmmoType");

	Params::FWGamePlayerCharacter_CycleAmmoType Parms{};

	Parms.WeaponToCycle = WeaponToCycle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.DropAllItems
// (Final, Native, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::DropAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "DropAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.EnablePermanentADS
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::EnablePermanentADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "EnablePermanentADS");

	Params::FWGamePlayerCharacter_EnablePermanentADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.FireEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::FireEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "FireEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.FireStoppedEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::FireStoppedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "FireStoppedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ForceAllowCloseContainer
// (Final, Native, Public, BlueprintCallable)

void AFWGamePlayerCharacter::ForceAllowCloseContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ForceAllowCloseContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ForceCanLoot
// (Final, Native, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::ForceCanLoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ForceCanLoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetBackpackRig
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetBackpackRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetBackpackRig");

	Params::FWGamePlayerCharacter_GetBackpackRig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetBestContainer
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FInventoryItemDetails&     ItemDetails                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             StackCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWRigContainersComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFWRigContainersComponent* AFWGamePlayerCharacter::GetBestContainer(const struct FInventoryItemDetails& ItemDetails, const int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetBestContainer");

	Params::FWGamePlayerCharacter_GetBestContainer Parms{};

	Parms.ItemDetails = std::move(ItemDetails);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetBestDangleSlot
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    AllowFixedSlots                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowLooseSlots                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Unique                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AFWGamePlayerCharacter::GetBestDangleSlot(bool AllowFixedSlots, bool AllowLooseSlots, bool Unique)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetBestDangleSlot");

	Params::FWGamePlayerCharacter_GetBestDangleSlot Parms{};

	Parms.AllowFixedSlots = AllowFixedSlots;
	Parms.AllowLooseSlots = AllowLooseSlots;
	Parms.Unique = Unique;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetBestDangleSwap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    AllowFixedSlots                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowLooseSlots                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AFWGamePlayerCharacter::GetBestDangleSwap(bool AllowFixedSlots, bool AllowLooseSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetBestDangleSwap");

	Params::FWGamePlayerCharacter_GetBestDangleSwap Parms{};

	Parms.AllowFixedSlots = AllowFixedSlots;
	Parms.AllowLooseSlots = AllowLooseSlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* AFWGamePlayerCharacter::GetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetCamera");

	Params::FWGamePlayerCharacter_GetCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetCameraDistance
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGamePlayerCharacter::GetCameraDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetCameraDistance");

	Params::FWGamePlayerCharacter_GetCameraDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetCameraObject
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* AFWGamePlayerCharacter::GetCameraObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetCameraObject");

	Params::FWGamePlayerCharacter_GetCameraObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetCurrencys
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TMap<class FName, struct FCurrencyDetails>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, struct FCurrencyDetails> AFWGamePlayerCharacter::GetCurrencys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetCurrencys");

	Params::FWGamePlayerCharacter_GetCurrencys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetCurrentThrowableIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AFWGamePlayerCharacter::GetCurrentThrowableIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetCurrentThrowableIndex");

	Params::FWGamePlayerCharacter_GetCurrentThrowableIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetDeployableActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWDeployableActorPlacement*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFWDeployableActorPlacement* AFWGamePlayerCharacter::GetDeployableActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetDeployableActor");

	Params::FWGamePlayerCharacter_GetDeployableActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetInventoryStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetInventoryStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetInventoryStatus");

	Params::FWGamePlayerCharacter_GetInventoryStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetIsExtracted
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetIsExtracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetIsExtracted");

	Params::FWGamePlayerCharacter_GetIsExtracted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetLootTimer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGamePlayerCharacter::GetLootTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetLootTimer");

	Params::FWGamePlayerCharacter_GetLootTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetMaxSprintSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGamePlayerCharacter::GetMaxSprintSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetMaxSprintSpeed");

	Params::FWGamePlayerCharacter_GetMaxSprintSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetMinigameTargetPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* AFWGamePlayerCharacter::GetMinigameTargetPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetMinigameTargetPawn");

	Params::FWGamePlayerCharacter_GetMinigameTargetPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetMountedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AFWWeaponBase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFWWeaponBase* AFWGamePlayerCharacter::GetMountedWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetMountedWeapon");

	Params::FWGamePlayerCharacter_GetMountedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetOldGearPickedUp
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetOldGearPickedUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetOldGearPickedUp");

	Params::FWGamePlayerCharacter_GetOldGearPickedUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetRecentlyOpenedContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetRecentlyOpenedContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetRecentlyOpenedContainer");

	Params::FWGamePlayerCharacter_GetRecentlyOpenedContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetTraceSize
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFWGamePlayerCharacter::GetTraceSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetTraceSize");

	Params::FWGamePlayerCharacter_GetTraceSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetUseControllFeeback
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetUseControllFeeback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetUseControllFeeback");

	Params::FWGamePlayerCharacter_GetUseControllFeeback Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetUsingMouseAndKeyboard
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetUsingMouseAndKeyboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetUsingMouseAndKeyboard");

	Params::FWGamePlayerCharacter_GetUsingMouseAndKeyboard Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetWeapons
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class AFWWeaponBase*>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class AFWWeaponBase*> AFWGamePlayerCharacter::GetWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetWeapons");

	Params::FWGamePlayerCharacter_GetWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.HandleAltFire
// (Final, Native, Public, BlueprintCallable)

void AFWGamePlayerCharacter::HandleAltFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "HandleAltFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.InitialWeaponEquiped
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const TArray<struct FGameplayTag>&      CompatibleAmmo                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::InitialWeaponEquiped(const TArray<struct FGameplayTag>& CompatibleAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "InitialWeaponEquiped");

	Params::FWGamePlayerCharacter_InitialWeaponEquiped Parms{};

	Parms.CompatibleAmmo = std::move(CompatibleAmmo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.IsCrouched
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::IsCrouched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "IsCrouched");

	Params::FWGamePlayerCharacter_IsCrouched Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.ItemLooted
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    Successfully                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LootedIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FullRefresh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ItemLooted(bool Successfully, int32 LootedIndex, bool FullRefresh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ItemLooted");

	Params::FWGamePlayerCharacter_ItemLooted Parms{};

	Parms.Successfully = Successfully;
	Parms.LootedIndex = LootedIndex;
	Parms.FullRefresh = FullRefresh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.LootableDangle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Dangle                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::LootableDangle(class AActor* Dangle, bool InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "LootableDangle");

	Params::FWGamePlayerCharacter_LootableDangle Parms{};

	Parms.Dangle = Dangle;
	Parms.InRange = InRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.LootableItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::LootableItem(class AActor* Item, bool InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "LootableItem");

	Params::FWGamePlayerCharacter_LootableItem Parms{};

	Parms.Item = Item;
	Parms.InRange = InRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.LootBody
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGameAICharacter*               Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::LootBody(class AFWGameAICharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "LootBody");

	Params::FWGamePlayerCharacter_LootBody Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.LootContainerItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::LootContainerItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "LootContainerItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.LootFailure
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELootFailerReason                       FailReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::LootFailure(ELootFailerReason FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "LootFailure");

	Params::FWGamePlayerCharacter_LootFailure Parms{};

	Parms.FailReason = FailReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.LootingReleased
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::LootingReleased(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "LootingReleased");

	Params::FWGamePlayerCharacter_LootingReleased Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.MulticastBroadcastExtracted
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::MulticastBroadcastExtracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "MulticastBroadcastExtracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.NewAmmoCount
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FAmmoStack>&        Ammo                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::NewAmmoCount(const TArray<struct FAmmoStack>& Ammo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "NewAmmoCount");

	Params::FWGamePlayerCharacter_NewAmmoCount Parms{};

	Parms.Ammo = std::move(Ammo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.OldGearPickedUp
// (Final, Native, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::OldGearPickedUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OldGearPickedUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.OnEquipHideFirearm
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bHide                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::OnEquipHideFirearm(bool bHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnEquipHideFirearm");

	Params::FWGamePlayerCharacter_OnEquipHideFirearm Parms{};

	Parms.bHide = bHide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnExitADSEvent
// (Event, Public, BlueprintEvent)

void AFWGamePlayerCharacter::OnExitADSEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnExitADSEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnExitOverTheShoulderEvent
// (Event, Public, BlueprintEvent)

void AFWGamePlayerCharacter::OnExitOverTheShoulderEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnExitOverTheShoulderEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnHealthDecreased
// (Event, Public, BlueprintEvent)

void AFWGamePlayerCharacter::OnHealthDecreased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnHealthDecreased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnInADSEvent
// (Event, Public, BlueprintEvent)

void AFWGamePlayerCharacter::OnInADSEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnInADSEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnIntOverTheShoulderEvent
// (Event, Public, BlueprintEvent)

void AFWGamePlayerCharacter::OnIntOverTheShoulderEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnIntOverTheShoulderEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnPlayerExtracted
// (Event, Protected, BlueprintEvent)

void AFWGamePlayerCharacter::OnPlayerExtracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnPlayerExtracted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.OnRep_WeaponAudioTagsUpdated
// (Native, Event, Protected, BlueprintEvent)

void AFWGamePlayerCharacter::OnRep_WeaponAudioTagsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnRep_WeaponAudioTagsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.OnUseThrowable
// (Final, Native, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::OnUseThrowable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnUseThrowable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.OpenContainer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASInventoryContainer*             Container                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::OpenContainer(class ASInventoryContainer* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OpenContainer");

	Params::FWGamePlayerCharacter_OpenContainer Parms{};

	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.OpenCrabBot
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UFWRigContainersComponent*        CrabBotContainer                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWMultiRigDanglySlot*            CrabBotMultiDanglySlot                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::OpenCrabBot(class UFWRigContainersComponent* CrabBotContainer, class UFWMultiRigDanglySlot* CrabBotMultiDanglySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OpenCrabBot");

	Params::FWGamePlayerCharacter_OpenCrabBot Parms{};

	Parms.CrabBotContainer = CrabBotContainer;
	Parms.CrabBotMultiDanglySlot = CrabBotMultiDanglySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RemoveDangle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    ContainerSlot                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RemoveDangle(const class FString& ContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RemoveDangle");

	Params::FWGamePlayerCharacter_RemoveDangle Parms{};

	Parms.ContainerSlot = std::move(ContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestAddRigWeapons
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Primary                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<struct FFWModifiedPart>&   PrimayModifiedParts                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FFWModifiedStatsPart&      PrimaryModifiedStats                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FFWScopeDefinitions&       PrimaryScopeDA                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Secondary                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<struct FFWModifiedPart>&   SecondaryModifiedParts                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FFWModifiedStatsPart&      SecondaryModifiedStats                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FFWScopeDefinitions&       SecondaryScopeDA                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       Throw                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestAddRigWeapons(const struct FDataTableRowHandle& Primary, const TArray<struct FFWModifiedPart>& PrimayModifiedParts, const struct FFWModifiedStatsPart& PrimaryModifiedStats, const struct FFWScopeDefinitions& PrimaryScopeDA, const struct FDataTableRowHandle& Secondary, const TArray<struct FFWModifiedPart>& SecondaryModifiedParts, const struct FFWModifiedStatsPart& SecondaryModifiedStats, const struct FFWScopeDefinitions& SecondaryScopeDA, const struct FDataTableRowHandle& Throw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestAddRigWeapons");

	Params::FWGamePlayerCharacter_RequestAddRigWeapons Parms{};

	Parms.Primary = std::move(Primary);
	Parms.PrimayModifiedParts = std::move(PrimayModifiedParts);
	Parms.PrimaryModifiedStats = std::move(PrimaryModifiedStats);
	Parms.PrimaryScopeDA = std::move(PrimaryScopeDA);
	Parms.Secondary = std::move(Secondary);
	Parms.SecondaryModifiedParts = std::move(SecondaryModifiedParts);
	Parms.SecondaryModifiedStats = std::move(SecondaryModifiedStats);
	Parms.SecondaryScopeDA = std::move(SecondaryScopeDA);
	Parms.Throw = std::move(Throw);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestCloseContainer
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestCloseContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestCloseContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestCloseCrabBot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestCloseCrabBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestCloseCrabBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestDangleSwap
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              FromCrabBot                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ToCrabBot                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OldContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestDangleSwap(class AActor* DangleContainer, const bool FromCrabBot, const class FString& NewContainerSlot, const bool ToCrabBot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestDangleSwap");

	Params::FWGamePlayerCharacter_RequestDangleSwap Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.FromCrabBot = FromCrabBot;
	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.ToCrabBot = ToCrabBot;
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestItemSwap
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class UFWRigContainersComponent*        OldContainer                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWRigContainersComponent*        NewContainer                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestItemSwap(class UFWRigContainersComponent* OldContainer, int32 ItemIndex, class UFWRigContainersComponent* NewContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestItemSwap");

	Params::FWGamePlayerCharacter_RequestItemSwap Parms{};

	Parms.OldContainer = OldContainer;
	Parms.ItemIndex = ItemIndex;
	Parms.NewContainer = NewContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootAllContainerItems
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// int32                                   RevealedCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASInventoryContainer*             LootContainer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootAllContainerItems(int32 RevealedCount, class ASInventoryContainer* LootContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootAllContainerItems");

	Params::FWGamePlayerCharacter_RequestLootAllContainerItems Parms{};

	Parms.RevealedCount = RevealedCount;
	Parms.LootContainer = LootContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootBody
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AFWGameAICharacter*               Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootBody(class AFWGameAICharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootBody");

	Params::FWGamePlayerCharacter_RequestLootBody Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootContainerCurrency
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASInventoryContainer*             LootContainer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootContainerCurrency(int32 ItemIndex, class ASInventoryContainer* LootContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootContainerCurrency");

	Params::FWGamePlayerCharacter_RequestLootContainerCurrency Parms{};

	Parms.ItemIndex = ItemIndex;
	Parms.LootContainer = LootContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootContainerItem
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AFWGamePlayerCharacter*           Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASInventoryContainer*             LootContainer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWRigContainersComponent*        ToContainer                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootContainerItem(class AFWGamePlayerCharacter* Character, int32 ItemIndex, class ASInventoryContainer* LootContainer, class UFWRigContainersComponent* ToContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootContainerItem");

	Params::FWGamePlayerCharacter_RequestLootContainerItem Parms{};

	Parms.Character = Character;
	Parms.ItemIndex = ItemIndex;
	Parms.LootContainer = LootContainer;
	Parms.ToContainer = ToContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootCurrency
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FContainerItem&            CurrencyItem                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootCurrency(const struct FContainerItem& CurrencyItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootCurrency");

	Params::FWGamePlayerCharacter_RequestLootCurrency Parms{};

	Parms.CurrencyItem = std::move(CurrencyItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootDangle
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootDangle(class AActor* DangleContainer, const class FString& NewContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootDangle");

	Params::FWGamePlayerCharacter_RequestLootDangle Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestLootItem
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class UFWRigContainersComponent*        ToContainer                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestLootItem(class UFWRigContainersComponent* ToContainer, class AActor* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestLootItem");

	Params::FWGamePlayerCharacter_RequestLootItem Parms{};

	Parms.ToContainer = ToContainer;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestOpenContainer
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AFWGamePlayerCharacter*           Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASInventoryContainer*             Container                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestOpenContainer(class AFWGamePlayerCharacter* Character, class ASInventoryContainer* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestOpenContainer");

	Params::FWGamePlayerCharacter_RequestOpenContainer Parms{};

	Parms.Character = Character;
	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestOpenCrabBot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestOpenCrabBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestOpenCrabBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestRelevantCrabBotContainer
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class UFWCrabBotInventory*              CrabBotInventory                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestRelevantCrabBotContainer(class UFWCrabBotInventory* CrabBotInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestRelevantCrabBotContainer");

	Params::FWGamePlayerCharacter_RequestRelevantCrabBotContainer Parms{};

	Parms.CrabBotInventory = CrabBotInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestRemoveDangle
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// const class FString&                    ContainerSlot                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestRemoveDangle(const class FString& ContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestRemoveDangle");

	Params::FWGamePlayerCharacter_RequestRemoveDangle Parms{};

	Parms.ContainerSlot = std::move(ContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestRemoveItem
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class UFWRigContainersComponent*        ToContainer                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestRemoveItem(class UFWRigContainersComponent* ToContainer, int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestRemoveItem");

	Params::FWGamePlayerCharacter_RequestRemoveItem Parms{};

	Parms.ToContainer = ToContainer;
	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestReplaceDangle
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestReplaceDangle(class AActor* DangleContainer, const class FString& NewContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestReplaceDangle");

	Params::FWGamePlayerCharacter_RequestReplaceDangle Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestStartLootingContainerItem
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestStartLootingContainerItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestStartLootingContainerItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestStartLootingDangle
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestStartLootingDangle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestStartLootingDangle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestStartLootingItem
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestStartLootingItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestStartLootingItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestStartSwappingDangle
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestStartSwappingDangle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestStartSwappingDangle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestStartSwappingItem
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::RequestStartSwappingItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestStartSwappingItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RequestUseDeployable
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// const TSoftClassPtr<class UClass>&      Deployable                                             (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                DeployLocation                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    DanglyAttachPoint                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MovingPlatform                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RequestUseDeployable(const TSoftClassPtr<class UClass>& Deployable, const struct FTransform& DeployLocation, const class FString& DanglyAttachPoint, class AActor* MovingPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RequestUseDeployable");

	Params::FWGamePlayerCharacter_RequestUseDeployable Parms{};

	Parms.Deployable = Deployable;
	Parms.DeployLocation = std::move(DeployLocation);
	Parms.DanglyAttachPoint = std::move(DanglyAttachPoint);
	Parms.MovingPlatform = MovingPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RigContainerUpdated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWRigContainersComponent*        Container                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RigContainerUpdated(class UFWRigContainersComponent* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RigContainerUpdated");

	Params::FWGamePlayerCharacter_RigContainerUpdated Parms{};

	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.RigDangleUpdated
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OldContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::RigDangleUpdated(const class FString& NewContainerSlot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "RigDangleUpdated");

	Params::FWGamePlayerCharacter_RigDangleUpdated Parms{};

	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SelectRandomSkin
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::SelectRandomSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SelectRandomSkin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerCharacter.ServerBroadcastExtracted
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void AFWGamePlayerCharacter::ServerBroadcastExtracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ServerBroadcastExtracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ServerCycleAmmoType
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class AFWWeaponBase*                    WeaponToCycle                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ServerCycleAmmoType(class AFWWeaponBase* WeaponToCycle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ServerCycleAmmoType");

	Params::FWGamePlayerCharacter_ServerCycleAmmoType Parms{};

	Parms.WeaponToCycle = WeaponToCycle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ServerLeanLeft
// (Net, NetReliable, Native, Event, Public, NetServer)

void AFWGamePlayerCharacter::ServerLeanLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ServerLeanLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ServerLeanLeftRest
// (Net, NetReliable, Native, Event, Public, NetServer)

void AFWGamePlayerCharacter::ServerLeanLeftRest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ServerLeanLeftRest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ServerLeanRight
// (Net, NetReliable, Native, Event, Public, NetServer)

void AFWGamePlayerCharacter::ServerLeanRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ServerLeanRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ServerLeanRightRest
// (Net, NetReliable, Native, Event, Public, NetServer)

void AFWGamePlayerCharacter::ServerLeanRightRest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ServerLeanRightRest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetConsumableCount
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetConsumableCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetConsumableCount");

	Params::FWGamePlayerCharacter_SetConsumableCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetCurrentRollLean
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             RollLean                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetCurrentRollLean(const float RollLean)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetCurrentRollLean");

	Params::FWGamePlayerCharacter_SetCurrentRollLean Parms{};

	Parms.RollLean = RollLean;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetCurrentYawLean
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             YawLean                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetCurrentYawLean(const float YawLean)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetCurrentYawLean");

	Params::FWGamePlayerCharacter_SetCurrentYawLean Parms{};

	Parms.YawLean = YawLean;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetDenyMovement
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    NewDenyMovement                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetDenyMovement(bool NewDenyMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetDenyMovement");

	Params::FWGamePlayerCharacter_SetDenyMovement Parms{};

	Parms.NewDenyMovement = NewDenyMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetIsAimingThrowable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bIsAiming                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetIsAimingThrowable(bool bIsAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetIsAimingThrowable");

	Params::FWGamePlayerCharacter_SetIsAimingThrowable Parms{};

	Parms.bIsAiming = bIsAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetIsCrouched
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              IsCrouched                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetIsCrouched(const bool IsCrouched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetIsCrouched");

	Params::FWGamePlayerCharacter_SetIsCrouched Parms{};

	Parms.IsCrouched = IsCrouched;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetIsExtracted
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bIsPlayerExtracted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetIsExtracted(bool bIsPlayerExtracted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetIsExtracted");

	Params::FWGamePlayerCharacter_SetIsExtracted Parms{};

	Parms.bIsPlayerExtracted = bIsPlayerExtracted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetMinigameTargetPawn
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ACharacter*                       NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetMinigameTargetPawn(class ACharacter* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetMinigameTargetPawn");

	Params::FWGamePlayerCharacter_SetMinigameTargetPawn Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetMountedWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    MountingWeapon                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetMountedWeapon(class AFWWeaponBase* MountingWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetMountedWeapon");

	Params::FWGamePlayerCharacter_SetMountedWeapon Parms{};

	Parms.MountingWeapon = MountingWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetOverTheShoulderAim
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const bool                              SetOverTheShoulderAimIsSet                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetOverTheShoulderAim(const bool SetOverTheShoulderAimIsSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetOverTheShoulderAim");

	Params::FWGamePlayerCharacter_SetOverTheShoulderAim Parms{};

	Parms.SetOverTheShoulderAimIsSet = SetOverTheShoulderAimIsSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SetWeaponIcons
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TSoftObjectPtr<class UTexture2D>& PrimaryIcon                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UTexture2D>& SecondaryIcon                                          (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UTexture2D>& ThrowIcon                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::SetWeaponIcons(const TSoftObjectPtr<class UTexture2D>& PrimaryIcon, const TSoftObjectPtr<class UTexture2D>& SecondaryIcon, const TSoftObjectPtr<class UTexture2D>& ThrowIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SetWeaponIcons");

	Params::FWGamePlayerCharacter_SetWeaponIcons Parms{};

	Parms.PrimaryIcon = PrimaryIcon;
	Parms.SecondaryIcon = SecondaryIcon;
	Parms.ThrowIcon = ThrowIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ShowCrosshair
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNewShowCrosshair                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::ShowCrosshair(bool bNewShowCrosshair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ShowCrosshair");

	Params::FWGamePlayerCharacter_ShowCrosshair Parms{};

	Parms.bNewShowCrosshair = bNewShowCrosshair;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGamePlayerCharacter.StartDelayedLootPrompt
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   LootTimer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      LootName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const EStoreCategory                    LootType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::StartDelayedLootPrompt(float LootTimer, const class FText& LootName, const EStoreCategory LootType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StartDelayedLootPrompt");

	Params::FWGamePlayerCharacter_StartDelayedLootPrompt Parms{};

	Parms.LootTimer = LootTimer;
	Parms.LootName = std::move(LootName);
	Parms.LootType = LootType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StartDeploying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AFWDeployableActorPlacement>DeployablePlacementClass                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              Replicated                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::StartDeploying(TSubclassOf<class AFWDeployableActorPlacement> DeployablePlacementClass, const bool Replicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StartDeploying");

	Params::FWGamePlayerCharacter_StartDeploying Parms{};

	Parms.DeployablePlacementClass = DeployablePlacementClass;
	Parms.Replicated = Replicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StartLooting
// (Final, Native, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::StartLooting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StartLooting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StartLootTimer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   LootTimer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::StartLootTimer(float LootTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StartLootTimer");

	Params::FWGamePlayerCharacter_StartLootTimer Parms{};

	Parms.LootTimer = LootTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StartMounting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    MountingWeapon                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USceneComponent*            MountingComponent                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinYawRotationRange                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxYawRotationRange                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinPitchRotationRange                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxPitchRotationRange                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::StartMounting(class AFWWeaponBase* MountingWeapon, const class USceneComponent* MountingComponent, const float MinYawRotationRange, const float MaxYawRotationRange, const float MinPitchRotationRange, const float MaxPitchRotationRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StartMounting");

	Params::FWGamePlayerCharacter_StartMounting Parms{};

	Parms.MountingWeapon = MountingWeapon;
	Parms.MountingComponent = MountingComponent;
	Parms.MinYawRotationRange = MinYawRotationRange;
	Parms.MaxYawRotationRange = MaxYawRotationRange;
	Parms.MinPitchRotationRange = MinPitchRotationRange;
	Parms.MaxPitchRotationRange = MaxPitchRotationRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StopDelayedLootPrompt
// (Native, Event, Protected, BlueprintEvent)

void AFWGamePlayerCharacter::StopDelayedLootPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StopDelayedLootPrompt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StopDeploying
// (Final, Native, Public, BlueprintCallable)

void AFWGamePlayerCharacter::StopDeploying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StopDeploying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StopLooting
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::StopLooting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StopLooting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StopLootTimer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::StopLootTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StopLootTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.StopMounting
// (Final, Native, Public, BlueprintCallable)

void AFWGamePlayerCharacter::StopMounting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "StopMounting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.SwapShoulders
// (Final, Native, Public, BlueprintCallable)

void AFWGamePlayerCharacter::SwapShoulders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "SwapShoulders");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ThrowThrowable
// (Final, Native, Protected, BlueprintCallable)

void AFWGamePlayerCharacter::ThrowThrowable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ThrowThrowable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.TickCameraLerpThrowable
// (Final, Native, Public)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::TickCameraLerpThrowable(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "TickCameraLerpThrowable");

	Params::FWGamePlayerCharacter_TickCameraLerpThrowable Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.TraceForLoot
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor**                          HitActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::TraceForLoot(class AActor** HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "TraceForLoot");

	Params::FWGamePlayerCharacter_TraceForLoot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitActor != nullptr)
		*HitActor = Parms.HitActor;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateCurrency
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCurrencyDetails&          CurrencyAmount                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateCurrency(class FName Key, const struct FCurrencyDetails& CurrencyAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateCurrency");

	Params::FWGamePlayerCharacter_UpdateCurrency Parms{};

	Parms.Key = Key;
	Parms.CurrencyAmount = std::move(CurrencyAmount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateFaceRotateInterpSpeed
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   NewFaceRotateInterpSpeed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateFaceRotateInterpSpeed(float NewFaceRotateInterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateFaceRotateInterpSpeed");

	Params::FWGamePlayerCharacter_UpdateFaceRotateInterpSpeed Parms{};

	Parms.NewFaceRotateInterpSpeed = NewFaceRotateInterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateInventoryStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    NewStatus                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateInventoryStatus(bool NewStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateInventoryStatus");

	Params::FWGamePlayerCharacter_UpdateInventoryStatus Parms{};

	Parms.NewStatus = NewStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateInventoryWeight
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// float                                   NewWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateInventoryWeight(float NewWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateInventoryWeight");

	Params::FWGamePlayerCharacter_UpdateInventoryWeight Parms{};

	Parms.NewWeight = NewWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateLootSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   NewSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateLootSetting(uint8 NewSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateLootSetting");

	Params::FWGamePlayerCharacter_UpdateLootSetting Parms{};

	Parms.NewSetting = NewSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateLootUI
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LootedIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FullRefresh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateLootUI(bool Success, int32 LootedIndex, bool FullRefresh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateLootUI");

	Params::FWGamePlayerCharacter_UpdateLootUI Parms{};

	Parms.Success = Success;
	Parms.LootedIndex = LootedIndex;
	Parms.FullRefresh = FullRefresh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateRigDangleUI
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OldContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateRigDangleUI(const class FString& NewContainerSlot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateRigDangleUI");

	Params::FWGamePlayerCharacter_UpdateRigDangleUI Parms{};

	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateSkillsViewModel
// (Final, Native, Private)
// Parameters:
// const class UFWSkillDefinition*         InSkillDef                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateSkillsViewModel(const class UFWSkillDefinition* InSkillDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateSkillsViewModel");

	Params::FWGamePlayerCharacter_UpdateSkillsViewModel Parms{};

	Parms.InSkillDef = InSkillDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UpdateWeaponIcons
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const TSoftObjectPtr<class UTexture2D>& PrimaryIcon                                            (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UTexture2D>& SecondaryIcon                                          (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UTexture2D>& ThrowIcon                                              (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UpdateWeaponIcons(const TSoftObjectPtr<class UTexture2D>& PrimaryIcon, const TSoftObjectPtr<class UTexture2D>& SecondaryIcon, const TSoftObjectPtr<class UTexture2D>& ThrowIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UpdateWeaponIcons");

	Params::FWGamePlayerCharacter_UpdateWeaponIcons Parms{};

	Parms.PrimaryIcon = PrimaryIcon;
	Parms.SecondaryIcon = SecondaryIcon;
	Parms.ThrowIcon = ThrowIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.UseDeployable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Deployable                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerCharacter::UseDeployable(TSoftClassPtr<class UClass> Deployable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "UseDeployable");

	Params::FWGamePlayerCharacter_UseDeployable Parms{};

	Parms.Deployable = Deployable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.ValidateLootables
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AFWGamePlayerCharacter::ValidateLootables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "ValidateLootables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerCharacter.CanAimThrowable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::CanAimThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "CanAimThrowable");

	Params::FWGamePlayerCharacter_CanAimThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.CanThrowThrowable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::CanThrowThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "CanThrowThrowable");

	Params::FWGamePlayerCharacter_CanThrowThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetHitReactionMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* AFWGamePlayerCharacter::GetHitReactionMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetHitReactionMontage");

	Params::FWGamePlayerCharacter_GetHitReactionMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.GetIsOverTheShoulderAim
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWGamePlayerCharacter::GetIsOverTheShoulderAim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "GetIsOverTheShoulderAim");

	Params::FWGamePlayerCharacter_GetIsOverTheShoulderAim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerCharacter.OnOverShoulder
// (Final, Native, Protected, Const)

void AFWGamePlayerCharacter::OnOverShoulder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerCharacter", "OnOverShoulder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.ClientShowPostGameUI
// (Net, NetReliable, Native, Event, Protected, NetClient)

void AFWGamePlayerController::ClientShowPostGameUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ClientShowPostGameUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.HandleOnExtracted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsTunnelExtract                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::HandleOnExtracted(bool bIsTunnelExtract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "HandleOnExtracted");

	Params::FWGamePlayerController_HandleOnExtracted Parms{};

	Parms.bIsTunnelExtract = bIsTunnelExtract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.HandleTargetedByAICountChanged
// (Final, Native, Private)
// Parameters:
// class UFWAIAwarenessComponent_Player*   AwarenessComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::HandleTargetedByAICountChanged(class UFWAIAwarenessComponent_Player* AwarenessComponent, class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "HandleTargetedByAICountChanged");

	Params::FWGamePlayerController_HandleTargetedByAICountChanged Parms{};

	Parms.AwarenessComponent = AwarenessComponent;
	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.OnRep_CountOfAITargettingPlayer
// (Final, Native, Protected)

void AFWGamePlayerController::OnRep_CountOfAITargettingPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "OnRep_CountOfAITargettingPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.RemoteCommand
// (Final, Exec, Native, Protected)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::RemoteCommand(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "RemoteCommand");

	Params::FWGamePlayerController_RemoteCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.RequestSpawnItems
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Location                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::RequestSpawnItems(TSubclassOf<class AActor> Class_0, const struct FTransform& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "RequestSpawnItems");

	Params::FWGamePlayerController_RequestSpawnItems Parms{};

	Parms.Class_0 = Class_0;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.ReturnToHub
// (Final, Native, Public, BlueprintCallable)

void AFWGamePlayerController::ReturnToHub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ReturnToHub");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.ServerHandleOnExtracted
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AFWGamePlayerController::ServerHandleOnExtracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ServerHandleOnExtracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.ServerInstigatedDamage
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDamageType*                DamageType                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::ServerInstigatedDamage(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ServerInstigatedDamage");

	Params::FWGamePlayerController_ServerInstigatedDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.DamagedActor = DamagedActor;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWGamePlayerController.ServerRemoteCommand
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::ServerRemoteCommand(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ServerRemoteCommand");

	Params::FWGamePlayerController_ServerRemoteCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.ServerReturnToHub
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AFWGamePlayerController::ServerReturnToHub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ServerReturnToHub");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.ServerSuicide
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AFWGamePlayerController::ServerSuicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "ServerSuicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.SetCenterTraceResult
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           NewMidpointHitActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGamePlayerController::SetCenterTraceResult(class AActor* NewMidpointHitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "SetCenterTraceResult");

	Params::FWGamePlayerController_SetCenterTraceResult Parms{};

	Parms.NewMidpointHitActor = NewMidpointHitActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.SetPlayerPlay
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)

void AFWGamePlayerController::SetPlayerPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "SetPlayerPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.SetPlayerSpectate
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)

void AFWGamePlayerController::SetPlayerSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "SetPlayerSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.Suicide
// (Exec, Native, Public)

void AFWGamePlayerController::Suicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "Suicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.TriggerCrash
// (Final, Exec, Native, Private)

void AFWGamePlayerController::TriggerCrash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "TriggerCrash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGamePlayerController.UseExtractionCamera
// (Event, Protected, BlueprintEvent)

void AFWGamePlayerController::UseExtractionCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "UseExtractionCamera");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWGamePlayerController.GetCenterTraceActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AFWGamePlayerController::GetCenterTraceActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "GetCenterTraceActor");

	Params::FWGamePlayerController_GetCenterTraceActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGamePlayerController.GetCenterTraceComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AFWGamePlayerController::GetCenterTraceComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGamePlayerController", "GetCenterTraceComponent");

	Params::FWGamePlayerController_GetCenterTraceComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetFWGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFWGameUserSettings*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFWGameUserSettings* UFWGameUserSettings::GetFWGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWGameUserSettings", "GetFWGameUserSettings");

	Params::FWGameUserSettings_GetFWGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.ApplyVoiceSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFWLocalPlayerVoiceSubsystem*     Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::ApplyVoiceSettings(class UFWLocalPlayerVoiceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "ApplyVoiceSettings");

	Params::FWGameUserSettings_ApplyVoiceSettings Parms{};

	Parms.Subsystem = Subsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetCustomResolutionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InCustomResolutionScale                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetCustomResolutionScale(float InCustomResolutionScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetCustomResolutionScale");

	Params::FWGameUserSettings_SetCustomResolutionScale Parms{};

	Parms.InCustomResolutionScale = InCustomResolutionScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetDisplayGamma
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InGamma                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetDisplayGamma(float InGamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetDisplayGamma");

	Params::FWGameUserSettings_SetDisplayGamma Parms{};

	Parms.InGamma = InGamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetDisplayLootCursor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   InDisplay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetDisplayLootCursor(uint8 InDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetDisplayLootCursor");

	Params::FWGameUserSettings_SetDisplayLootCursor Parms{};

	Parms.InDisplay = InDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetDLSS_FrameGen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFrameGen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetDLSS_FrameGen(bool InFrameGen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetDLSS_FrameGen");

	Params::FWGameUserSettings_SetDLSS_FrameGen Parms{};

	Parms.InFrameGen = InFrameGen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetFSR_FrameGen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFrameGen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetFSR_FrameGen(bool InFrameGen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetFSR_FrameGen");

	Params::FWGameUserSettings_SetFSR_FrameGen Parms{};

	Parms.InFrameGen = InFrameGen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetHUDFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InHUDFade                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetHUDFade(bool InHUDFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetHUDFade");

	Params::FWGameUserSettings_SetHUDFade Parms{};

	Parms.InHUDFade = InHUDFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetMinHUDFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinHUDFade                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetMinHUDFade(float InMinHUDFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetMinHUDFade");

	Params::FWGameUserSettings_SetMinHUDFade Parms{};

	Parms.InMinHUDFade = InMinHUDFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetMotionBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetMotionBlur(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetMotionBlur");

	Params::FWGameUserSettings_SetMotionBlur Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetSelectedVoiceInputDeviceId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetSelectedVoiceInputDeviceId(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetSelectedVoiceInputDeviceId");

	Params::FWGameUserSettings_SetSelectedVoiceInputDeviceId Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetSelectedVoiceOutputDeviceId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetSelectedVoiceOutputDeviceId(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetSelectedVoiceOutputDeviceId");

	Params::FWGameUserSettings_SetSelectedVoiceOutputDeviceId Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetUpscalingMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUpscalingMethod                        NewMethod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetUpscalingMethod(EUpscalingMethod NewMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetUpscalingMethod");

	Params::FWGameUserSettings_SetUpscalingMethod Parms{};

	Parms.NewMethod = NewMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetUpscalingQualityPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUpscalingQualityPreset                 NewQualityPreset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetUpscalingQualityPreset(EUpscalingQualityPreset NewQualityPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetUpscalingQualityPreset");

	Params::FWGameUserSettings_SetUpscalingQualityPreset Parms{};

	Parms.NewQualityPreset = NewQualityPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceActivityType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EFWVoiceActivityType              InVoiceActivityType                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceActivityType(const EFWVoiceActivityType InVoiceActivityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceActivityType");

	Params::FWGameUserSettings_SetVoiceActivityType Parms{};

	Parms.InVoiceActivityType = InVoiceActivityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceAutoGainControl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceAutoGainControl(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceAutoGainControl");

	Params::FWGameUserSettings_SetVoiceAutoGainControl Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceDTX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceDTX(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceDTX");

	Params::FWGameUserSettings_SetVoiceDTX Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceEchoCancellation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceEchoCancellation(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceEchoCancellation");

	Params::FWGameUserSettings_SetVoiceEchoCancellation Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceInputVolume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const float&                            Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceInputVolume(const float& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceInputVolume");

	Params::FWGameUserSettings_SetVoiceInputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceNoiseSuppression
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceNoiseSuppression(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceNoiseSuppression");

	Params::FWGameUserSettings_SetVoiceNoiseSuppression Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoiceOutputVolume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const float&                            Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoiceOutputVolume(const float& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoiceOutputVolume");

	Params::FWGameUserSettings_SetVoiceOutputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.SetVoicePlatformAEC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWGameUserSettings::SetVoicePlatformAEC(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "SetVoicePlatformAEC");

	Params::FWGameUserSettings_SetVoicePlatformAEC Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameUserSettings.GetCustomResolutionScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWGameUserSettings::GetCustomResolutionScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetCustomResolutionScale");

	Params::FWGameUserSettings_GetCustomResolutionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetDisplayGamma
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWGameUserSettings::GetDisplayGamma() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetDisplayGamma");

	Params::FWGameUserSettings_GetDisplayGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetDisplayLootCursor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UFWGameUserSettings::GetDisplayLootCursor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetDisplayLootCursor");

	Params::FWGameUserSettings_GetDisplayLootCursor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetDLSS_FrameGen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetDLSS_FrameGen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetDLSS_FrameGen");

	Params::FWGameUserSettings_GetDLSS_FrameGen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetFSR_FrameGen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetFSR_FrameGen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetFSR_FrameGen");

	Params::FWGameUserSettings_GetFSR_FrameGen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetHUDFade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetHUDFade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetHUDFade");

	Params::FWGameUserSettings_GetHUDFade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetMinHUDFade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWGameUserSettings::GetMinHUDFade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetMinHUDFade");

	Params::FWGameUserSettings_GetMinHUDFade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetMotionBlurAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWGameUserSettings::GetMotionBlurAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetMotionBlurAmount");

	Params::FWGameUserSettings_GetMotionBlurAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetSelectedVoiceInputDeviceId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFWGameUserSettings::GetSelectedVoiceInputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetSelectedVoiceInputDeviceId");

	Params::FWGameUserSettings_GetSelectedVoiceInputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetSelectedVoiceOutputDeviceId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFWGameUserSettings::GetSelectedVoiceOutputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetSelectedVoiceOutputDeviceId");

	Params::FWGameUserSettings_GetSelectedVoiceOutputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetUpscalingMethod
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUpscalingMethod                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUpscalingMethod UFWGameUserSettings::GetUpscalingMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetUpscalingMethod");

	Params::FWGameUserSettings_GetUpscalingMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetUpscalingQualityPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUpscalingQualityPreset                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUpscalingQualityPreset UFWGameUserSettings::GetUpscalingQualityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetUpscalingQualityPreset");

	Params::FWGameUserSettings_GetUpscalingQualityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceActivityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFWVoiceActivityType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFWVoiceActivityType UFWGameUserSettings::GetVoiceActivityType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceActivityType");

	Params::FWGameUserSettings_GetVoiceActivityType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceAutoGainControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetVoiceAutoGainControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceAutoGainControl");

	Params::FWGameUserSettings_GetVoiceAutoGainControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceDTX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetVoiceDTX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceDTX");

	Params::FWGameUserSettings_GetVoiceDTX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceEchoCancellation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetVoiceEchoCancellation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceEchoCancellation");

	Params::FWGameUserSettings_GetVoiceEchoCancellation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceInputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWGameUserSettings::GetVoiceInputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceInputVolume");

	Params::FWGameUserSettings_GetVoiceInputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceNoiseSuppression
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetVoiceNoiseSuppression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceNoiseSuppression");

	Params::FWGameUserSettings_GetVoiceNoiseSuppression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoiceOutputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWGameUserSettings::GetVoiceOutputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoiceOutputVolume");

	Params::FWGameUserSettings_GetVoiceOutputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.GetVoicePlatformAEC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::GetVoicePlatformAEC() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "GetVoicePlatformAEC");

	Params::FWGameUserSettings_GetVoicePlatformAEC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameUserSettings.IsDLSSEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWGameUserSettings::IsDLSSEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameUserSettings", "IsDLSSEnabled");

	Params::FWGameUserSettings_IsDLSSEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWGameVehicle.DefaultCriticalHitHandler
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWGameVehicle::DefaultCriticalHitHandler(class UPrimitiveComponent* Component, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UFWDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameVehicle", "DefaultCriticalHitHandler");

	Params::FWGameVehicle_DefaultCriticalHitHandler Parms{};

	Parms.Component = Component;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameVehicle.RegisterCriticalHitListeners
// (Native, Event, Protected, BlueprintEvent)

void AFWGameVehicle::RegisterCriticalHitListeners()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameVehicle", "RegisterCriticalHitListeners");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWGameVehicle.GetVehicleEyesViewPoint
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AFWGameVehicle::GetVehicleEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWGameVehicle", "GetVehicleEyesViewPoint");

	Params::FWGameVehicle_GetVehicleEyesViewPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function ForeverWinter.FWHardpointContainerComponent.AttachHardpointWeapon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              HardpointTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWHardpointContainerComponent::AttachHardpointWeapon(class AFWWeaponBase* Weapon, const struct FGameplayTag& HardpointTag, class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "AttachHardpointWeapon");

	Params::FWHardpointContainerComponent_AttachHardpointWeapon Parms{};

	Parms.Weapon = Weapon;
	Parms.HardpointTag = std::move(HardpointTag);
	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHardpointContainerComponent.ClearExcludeWeapons
// (Final, Native, Public, BlueprintCallable)

void UFWHardpointContainerComponent::ClearExcludeWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "ClearExcludeWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.ClearPrimaryTarget
// (Native, Public, BlueprintCallable)

void UFWHardpointContainerComponent::ClearPrimaryTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "ClearPrimaryTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.DestroyAllHardpointWeapons
// (Final, Native, Public, BlueprintCallable)

void UFWHardpointContainerComponent::DestroyAllHardpointWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "DestroyAllHardpointWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.EquipHardpointWeapon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              HardpointTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWHardpointContainerComponent::EquipHardpointWeapon(class AFWWeaponBase* Weapon, const struct FGameplayTag& HardpointTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "EquipHardpointWeapon");

	Params::FWHardpointContainerComponent_EquipHardpointWeapon Parms{};

	Parms.Weapon = Weapon;
	Parms.HardpointTag = std::move(HardpointTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.ExcludeWeaponClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             WeaponClass                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWHardpointContainerComponent::ExcludeWeaponClass(TSoftClassPtr<class UClass> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "ExcludeWeaponClass");

	Params::FWHardpointContainerComponent_ExcludeWeaponClass Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.FireHardpointWeaponWithTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              HardpointTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWHardpointContainerComponent::FireHardpointWeaponWithTag(const struct FGameplayTag& HardpointTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "FireHardpointWeaponWithTag");

	Params::FWHardpointContainerComponent_FireHardpointWeaponWithTag Parms{};

	Parms.HardpointTag = std::move(HardpointTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.GetMesh
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* UFWHardpointContainerComponent::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "GetMesh");

	Params::FWHardpointContainerComponent_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHardpointContainerComponent.GetTargetForWeapon
// (Native, Public, BlueprintCallable)
// Parameters:
// class AFWWeaponBase*                    Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UFWHardpointContainerComponent::GetTargetForWeapon(class AFWWeaponBase* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "GetTargetForWeapon");

	Params::FWHardpointContainerComponent_GetTargetForWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHardpointContainerComponent.GetWeaponFromTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFWWeaponBase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFWWeaponBase* UFWHardpointContainerComponent::GetWeaponFromTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "GetWeaponFromTag");

	Params::FWHardpointContainerComponent_GetWeaponFromTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHardpointContainerComponent.OnRep_AimReplication
// (Final, Native, Protected)

void UFWHardpointContainerComponent::OnRep_AimReplication()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "OnRep_AimReplication");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.SetPrimaryTargetActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWHardpointContainerComponent::SetPrimaryTargetActor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "SetPrimaryTargetActor");

	Params::FWHardpointContainerComponent_SetPrimaryTargetActor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.SetPrimaryTargetLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWHardpointContainerComponent::SetPrimaryTargetLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "SetPrimaryTargetLocation");

	Params::FWHardpointContainerComponent_SetPrimaryTargetLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.SpawnAllHardpoints
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UFWHardpointContainerComponent::SpawnAllHardpoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "SpawnAllHardpoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWHardpointContainerComponent.SpawnHardpoint
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           HardpointClass                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              HardpointTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEquipAsPrimary                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFWAIMechWeapon*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFWAIMechWeapon* UFWHardpointContainerComponent::SpawnHardpoint(class UClass* HardpointClass, const struct FGameplayTag& HardpointTag, class FName SocketName, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, bool bEquipAsPrimary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "SpawnHardpoint");

	Params::FWHardpointContainerComponent_SpawnHardpoint Parms{};

	Parms.HardpointClass = HardpointClass;
	Parms.HardpointTag = std::move(HardpointTag);
	Parms.SocketName = SocketName;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.bEquipAsPrimary = bEquipAsPrimary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHardpointContainerComponent.SpawnHardpointCollider
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              HardpointTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UFWHardpointContainerComponent::SpawnHardpointCollider(const struct FGameplayTag& HardpointTag, class FName SocketName, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const struct FVector& Extents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "SpawnHardpointCollider");

	Params::FWHardpointContainerComponent_SpawnHardpointCollider Parms{};

	Parms.HardpointTag = std::move(HardpointTag);
	Parms.SocketName = SocketName;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.Extents = std::move(Extents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHardpointContainerComponent.WasInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWHardpointContainerComponent::WasInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWHardpointContainerComponent", "WasInitialized");

	Params::FWHardpointContainerComponent_WasInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHUDFunctionLibrary.GetShouldShowHUD
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWHUDFunctionLibrary::GetShouldShowHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWHUDFunctionLibrary", "GetShouldShowHUD");

	Params::FWHUDFunctionLibrary_GetShouldShowHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWHUDFunctionLibrary.SetShouldShowHUD
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const bool                              NewShowHUD                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWHUDFunctionLibrary::SetShouldShowHUD(const bool NewShowHUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWHUDFunctionLibrary", "SetShouldShowHUD");

	Params::FWHUDFunctionLibrary_SetShouldShowHUD Parms{};

	Parms.NewShowHUD = NewShowHUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWInventoryShim.ClearGameInDatastore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWInventoryShim::ClearGameInDatastore(const class FString& SlotName, class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWInventoryShim", "ClearGameInDatastore");

	Params::FWInventoryShim_ClearGameInDatastore Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.Subsystem = Subsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWInventoryShim.HasGameInDatastore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWInventoryShim::HasGameInDatastore(const class FString& SlotName, class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWInventoryShim", "HasGameInDatastore");

	Params::FWInventoryShim_HasGameInDatastore Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.Subsystem = Subsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWInventoryShim.LoadGameFromDatastore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UFWInventoryShim::LoadGameFromDatastore(const class FString& SlotName, class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWInventoryShim", "LoadGameFromDatastore");

	Params::FWInventoryShim_LoadGameFromDatastore Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.Subsystem = Subsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWInventoryShim.SaveGameToDatastore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWPersistenceSubsystem*          Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWInventoryShim::SaveGameToDatastore(class USaveGame* SaveGame, const class FString& SlotName, class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWInventoryShim", "SaveGameToDatastore");

	Params::FWInventoryShim_SaveGameToDatastore Parms{};

	Parms.SaveGame = SaveGame;
	Parms.SlotName = std::move(SlotName);
	Parms.Subsystem = Subsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWInventoryShim.SetInventoryCrashContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FName                       Weapon1                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       Weapon2                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       Rig                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWInventoryShim::SetInventoryCrashContext(const class FName Weapon1, const class FName Weapon2, const class FName Rig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWInventoryShim", "SetInventoryCrashContext");

	Params::FWInventoryShim_SetInventoryCrashContext Parms{};

	Parms.Weapon1 = Weapon1;
	Parms.Weapon2 = Weapon2;
	Parms.Rig = Rig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadDigitWidget.HandleClicked
// (Final, Native, Private)

void UFWKeypadDigitWidget::HandleClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadDigitWidget", "HandleClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.OnClearKeyPress
// (Native, Event, Protected, BlueprintEvent)

void UFWKeypadPanel::OnClearKeyPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "OnClearKeyPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.OnDigitKeyPress
// (Native, Event, Protected, BlueprintEvent)

void UFWKeypadPanel::OnDigitKeyPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "OnDigitKeyPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.OnEnterKeyPress
// (Native, Event, Protected, BlueprintEvent)

void UFWKeypadPanel::OnEnterKeyPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "OnEnterKeyPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.OnKeypadDisabled
// (Native, Event, Protected, BlueprintEvent)

void UFWKeypadPanel::OnKeypadDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "OnKeypadDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.OnKeypadEnabled
// (Native, Event, Protected, BlueprintEvent)

void UFWKeypadPanel::OnKeypadEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "OnKeypadEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.OnPostBuild
// (Event, Public, BlueprintEvent)

void UFWKeypadPanel::OnPostBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "OnPostBuild");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWKeypadPanel.SendClearClicked
// (Final, Native, Public, BlueprintCallable)

void UFWKeypadPanel::SendClearClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "SendClearClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.SendDigitClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Digit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWKeypadPanel::SendDigitClicked(uint8 Digit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "SendDigitClicked");

	Params::FWKeypadPanel_SendDigitClicked Parms{};

	Parms.Digit = Digit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWKeypadPanel.SendEnterClicked
// (Final, Native, Public, BlueprintCallable)

void UFWKeypadPanel::SendEnterClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWKeypadPanel", "SendEnterClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleAdvertisement.OnUnlocked
// (Event, Public, BlueprintEvent)

void UFWLockPuzzleAdvertisement::OnUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleAdvertisement", "OnUnlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.FWLockPuzzleAdvertisement.SetPuzzleText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      PreText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      PostText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFWLockPuzzleAdvertisement::SetPuzzleText(const class FText& PreText, const class FText& PostText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleAdvertisement", "SetPuzzleText");

	Params::FWLockPuzzleAdvertisement_SetPuzzleText Parms{};

	Parms.PreText = std::move(PreText);
	Parms.PostText = std::move(PostText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWLockPuzzleLocation.ActivateDeathSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWCharacter*                     Victim                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::ActivateDeathSequence(class AFWCharacter* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "ActivateDeathSequence");

	Params::FWLockPuzzleLocation_ActivateDeathSequence Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.GetSkelMesh
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AFWLockPuzzleLocation::GetSkelMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "GetSkelMesh");

	Params::FWLockPuzzleLocation_GetSkelMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandleBeginComponentOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandleBeginComponentOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandleBeginComponentOverlap");

	Params::FWLockPuzzleLocation_HandleBeginComponentOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandleEndComponentOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandleEndComponentOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandleEndComponentOverlap");

	Params::FWLockPuzzleLocation_HandleEndComponentOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandlePuzzleBeganClosing
// (Final, Native, Private)
// Parameters:
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandlePuzzleBeganClosing(int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandlePuzzleBeganClosing");

	Params::FWLockPuzzleLocation_HandlePuzzleBeganClosing Parms{};

	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandlePuzzleDestroy
// (Final, Native, Private)
// Parameters:
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandlePuzzleDestroy(int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandlePuzzleDestroy");

	Params::FWLockPuzzleLocation_HandlePuzzleDestroy Parms{};

	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandlePuzzleFailure
// (Final, Native, Private)
// Parameters:
// int32                                   AttemptsUsed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandlePuzzleFailure(int32 AttemptsUsed, float TotalDuration, int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandlePuzzleFailure");

	Params::FWLockPuzzleLocation_HandlePuzzleFailure Parms{};

	Parms.AttemptsUsed = AttemptsUsed;
	Parms.TotalDuration = TotalDuration;
	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandlePuzzleTimeout
// (Final, Native, Private)
// Parameters:
// int32                                   AttemptsUsed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandlePuzzleTimeout(int32 AttemptsUsed, float TotalDuration, int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandlePuzzleTimeout");

	Params::FWLockPuzzleLocation_HandlePuzzleTimeout Parms{};

	Parms.AttemptsUsed = AttemptsUsed;
	Parms.TotalDuration = TotalDuration;
	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandleRemovedPuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandleRemovedPuzzle(int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandleRemovedPuzzle");

	Params::FWLockPuzzleLocation_HandleRemovedPuzzle Parms{};

	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.HandleTriggerPuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::HandleTriggerPuzzle(int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "HandleTriggerPuzzle");

	Params::FWLockPuzzleLocation_HandleTriggerPuzzle Parms{};

	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.OnLocationSolved
// (Native, Event, Protected, BlueprintEvent)

void AFWLockPuzzleLocation::OnLocationSolved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "OnLocationSolved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.OnRep_SolutionMask
// (Final, Native, Protected)
// Parameters:
// int32                                   OldMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::OnRep_SolutionMask(int32 OldMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "OnRep_SolutionMask");

	Params::FWLockPuzzleLocation_OnRep_SolutionMask Parms{};

	Parms.OldMask = OldMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.OnSequenceEnd
// (Final, Native, Private)

void AFWLockPuzzleLocation::OnSequenceEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "OnSequenceEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.PlaySequence
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// class ULevelSequence*                   Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFWCharacter*                     Victim                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SequenceTransform                                      (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::PlaySequence(class ULevelSequence* Sequence, class AFWCharacter* Victim, const struct FTransform& SequenceTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "PlaySequence");

	Params::FWLockPuzzleLocation_PlaySequence Parms{};

	Parms.Sequence = Sequence;
	Parms.Victim = Victim;
	Parms.SequenceTransform = std::move(SequenceTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.SolvePuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PuzzleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWLockPuzzleLocation::SolvePuzzle(int32 PuzzleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "SolvePuzzle");

	Params::FWLockPuzzleLocation_SolvePuzzle Parms{};

	Parms.PuzzleIndex = PuzzleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWLockPuzzleLocation.TryTriggerPuzzle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWLockPuzzle**                   OutLockPuzzle                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AFWLockPuzzleLocation::TryTriggerPuzzle(class APlayerController* InPlayerController, class UFWLockPuzzle** OutLockPuzzle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "TryTriggerPuzzle");

	Params::FWLockPuzzleLocation_TryTriggerPuzzle Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLockPuzzle != nullptr)
		*OutLockPuzzle = Parms.OutLockPuzzle;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWLockPuzzleLocation.GetIsTerminalUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TerminalIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWLockPuzzleLocation::GetIsTerminalUnlocked(int32 TerminalIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "GetIsTerminalUnlocked");

	Params::FWLockPuzzleLocation_GetIsTerminalUnlocked Parms{};

	Parms.TerminalIndex = TerminalIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWLockPuzzleLocation.IsTerminalOccupied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TerminalIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFWLockPuzzleLocation::IsTerminalOccupied(int32 TerminalIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLockPuzzleLocation", "IsTerminalOccupied");

	Params::FWLockPuzzleLocation_IsTerminalOccupied Parms{};

	Parms.TerminalIndex = TerminalIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWLootTargetMarker.GetRootActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UFWLootTargetMarker::GetRootActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWLootTargetMarker", "GetRootActor");

	Params::FWLootTargetMarker_GetRootActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWMinigamePawn.FireWeapon
// (Final, Native, Protected, BlueprintCallable)

void AFWMinigamePawn::FireWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePawn", "FireWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigamePawn.OnDamaged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DamageTaken                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWMinigamePawn::OnDamaged(float DamageTaken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePawn", "OnDamaged");

	Params::FWMinigamePawn_OnDamaged Parms{};

	Parms.DamageTaken = DamageTaken;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWMinigamePawn.SetTarget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWMinigamePawn::SetTarget(class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePawn", "SetTarget");

	Params::FWMinigamePawn_SetTarget Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigamePlayerPawn.AddActorToRenderTarget
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWMinigamePlayerPawn::AddActorToRenderTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePlayerPawn", "AddActorToRenderTarget");

	Params::FWMinigamePlayerPawn_AddActorToRenderTarget Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.FWMinigamePlayerPawn.DisableScenario
// (Final, Native, Protected, BlueprintCallable)

void AFWMinigamePlayerPawn::DisableScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePlayerPawn", "DisableScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigamePlayerPawn.EnableScenario
// (Final, Native, Protected, BlueprintCallable)

void AFWMinigamePlayerPawn::EnableScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePlayerPawn", "EnableScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigamePlayerPawn.ServerEndMinigame
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWMinigamePlayerPawn::ServerEndMinigame(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePlayerPawn", "ServerEndMinigame");

	Params::FWMinigamePlayerPawn_ServerEndMinigame Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigamePlayerPawn.StopMinigame
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFWMinigamePlayerPawn::StopMinigame(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigamePlayerPawn", "StopMinigame");

	Params::FWMinigamePlayerPawn_StopMinigame Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWMinigameProjectile.OnOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFWMinigameProjectile::OnOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWMinigameProjectile", "OnOverlap");

	Params::FWMinigameProjectile_OnOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWObjectiveNameplateWidget.GetRootActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UFWObjectiveNameplateWidget::GetRootActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWObjectiveNameplateWidget", "GetRootActor");

	Params::FWObjectiveNameplateWidget_GetRootActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWOptionsFunctionLibrary.GetDisplayGamma
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWOptionsFunctionLibrary::GetDisplayGamma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWOptionsFunctionLibrary", "GetDisplayGamma");

	Params::FWOptionsFunctionLibrary_GetDisplayGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWOptionsFunctionLibrary.IsLanguageSelected
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWOptionsFunctionLibrary::IsLanguageSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWOptionsFunctionLibrary", "IsLanguageSelected");

	Params::FWOptionsFunctionLibrary_IsLanguageSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWOptionsFunctionLibrary.SetDisplayGamma
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   InGamma                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWOptionsFunctionLibrary::SetDisplayGamma(float InGamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWOptionsFunctionLibrary", "SetDisplayGamma");

	Params::FWOptionsFunctionLibrary_SetDisplayGamma Parms{};

	Parms.InGamma = InGamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWPlayerState_Default.OnRep_IsExtracted
// (Final, Native, Protected)

void AFWPlayerState_Default::OnRep_IsExtracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWPlayerState_Default", "OnRep_IsExtracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWPlayerState_Default.OnRep_IsPermanentlyDead
// (Final, Native, Protected)

void AFWPlayerState_Default::OnRep_IsPermanentlyDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWPlayerState_Default", "OnRep_IsPermanentlyDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWPlayerState_Default.SaveWindowedStats
// (Final, Native, Public, BlueprintCallable)

void AFWPlayerState_Default::SaveWindowedStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWPlayerState_Default", "SaveWindowedStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWQuestDataWidget.SetQuestProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FFWQuestTask>&      FWQuestTasks                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EFWQuestStatus                          Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWQuestDataWidget::SetQuestProgress(const TArray<struct FFWQuestTask>& FWQuestTasks, EFWQuestStatus Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWQuestDataWidget", "SetQuestProgress");

	Params::FWQuestDataWidget_SetQuestProgress Parms{};

	Parms.FWQuestTasks = std::move(FWQuestTasks);
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWQuestsWidget.PopulateQuestData
// (Final, Native, Public, BlueprintCallable)

void UFWQuestsWidget::PopulateQuestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWQuestsWidget", "PopulateQuestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWQuestsWidget.RefreshDelegate
// (Final, Native, Public)

void UFWQuestsWidget::RefreshDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWQuestsWidget", "RefreshDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWScrollBox.ScrollToDesiredViewAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAnimateScroll                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWScrollBox::ScrollToDesiredViewAlpha(float InAlpha, bool InAnimateScroll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "ScrollToDesiredViewAlpha");

	Params::FWScrollBox_ScrollToDesiredViewAlpha Parms{};

	Parms.InAlpha = InAlpha;
	Parms.InAnimateScroll = InAnimateScroll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWScrollBox.SimulateMouseWheel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InDelta                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWScrollBox::SimulateMouseWheel(const float InDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "SimulateMouseWheel");

	Params::FWScrollBox_SimulateMouseWheel Parms{};

	Parms.InDelta = InDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWScrollBox.StartSmoothScroll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             InDelta                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWScrollBox::StartSmoothScroll(const float InDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "StartSmoothScroll");

	Params::FWScrollBox_StartSmoothScroll Parms{};

	Parms.InDelta = InDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWScrollBox.StopSmoothScroll
// (Final, Native, Public, BlueprintCallable)

void UFWScrollBox::StopSmoothScroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "StopSmoothScroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWScrollBox.CanScroll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWScrollBox::CanScroll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "CanScroll");

	Params::FWScrollBox_CanScroll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWScrollBox.GetCurrentViewAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWScrollBox::GetCurrentViewAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "GetCurrentViewAlpha");

	Params::FWScrollBox_GetCurrentViewAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWScrollBox.IsSmoothScrolling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWScrollBox::IsSmoothScrolling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWScrollBox", "IsSmoothScrolling");

	Params::FWScrollBox_IsSmoothScrolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWSlider.SetOriginalValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWSlider::SetOriginalValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWSlider", "SetOriginalValue");

	Params::FWSlider_SetOriginalValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWTextureUtil.LoadTextureFromFile
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UFWTextureUtil::LoadTextureFromFile(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWTextureUtil", "LoadTextureFromFile");

	Params::FWTextureUtil_LoadTextureFromFile Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWTombStoneSave.GetClearSaveTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTimespan&                 SaveTimeDuration                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UFWTombStoneSave::GetClearSaveTime(const struct FTimespan& SaveTimeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "GetClearSaveTime");

	Params::FWTombStoneSave_GetClearSaveTime Parms{};

	Parms.SaveTimeDuration = std::move(SaveTimeDuration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWTombStoneSave.GetDeathData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSavedItem>*              ItemsBroughtIn                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>*     DangliesBroughtIn                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float*                                  CapsuleRadius                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWTombStoneSave::GetDeathData(TArray<struct FSavedItem>* ItemsBroughtIn, TArray<struct FDataTableRowHandle>* DangliesBroughtIn, float* CapsuleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "GetDeathData");

	Params::FWTombStoneSave_GetDeathData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemsBroughtIn != nullptr)
		*ItemsBroughtIn = std::move(Parms.ItemsBroughtIn);

	if (DangliesBroughtIn != nullptr)
		*DangliesBroughtIn = std::move(Parms.DangliesBroughtIn);

	if (CapsuleRadius != nullptr)
		*CapsuleRadius = Parms.CapsuleRadius;
}


// Function ForeverWinter.FWTombStoneSave.GetDisconnectedData
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FSavedItem>*              LootedItems                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>*     LootedDanglies                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float*                                  CapsuleRadius                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFWTombStoneSave::GetDisconnectedData(TArray<struct FSavedItem>* LootedItems, TArray<struct FDataTableRowHandle>* LootedDanglies, float* CapsuleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "GetDisconnectedData");

	Params::FWTombStoneSave_GetDisconnectedData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LootedItems != nullptr)
		*LootedItems = std::move(Parms.LootedItems);

	if (LootedDanglies != nullptr)
		*LootedDanglies = std::move(Parms.LootedDanglies);

	if (CapsuleRadius != nullptr)
		*CapsuleRadius = Parms.CapsuleRadius;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWTombStoneSave.GetLastDeathData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSavedContainer>*         RecoveredContainers                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FSavedFrame>*             RecoveredFrames                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FSavedWeapon>*            RecoveredWeapons                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FSavedItem>*              RecoveredWeaponParts                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFWTombStoneSave::GetLastDeathData(TArray<struct FSavedContainer>* RecoveredContainers, TArray<struct FSavedFrame>* RecoveredFrames, TArray<struct FSavedWeapon>* RecoveredWeapons, TArray<struct FSavedItem>* RecoveredWeaponParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "GetLastDeathData");

	Params::FWTombStoneSave_GetLastDeathData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RecoveredContainers != nullptr)
		*RecoveredContainers = std::move(Parms.RecoveredContainers);

	if (RecoveredFrames != nullptr)
		*RecoveredFrames = std::move(Parms.RecoveredFrames);

	if (RecoveredWeapons != nullptr)
		*RecoveredWeapons = std::move(Parms.RecoveredWeapons);

	if (RecoveredWeaponParts != nullptr)
		*RecoveredWeaponParts = std::move(Parms.RecoveredWeaponParts);
}


// Function ForeverWinter.FWTombStoneSave.GetMapName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFWTombStoneSave::GetMapName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "GetMapName");

	Params::FWTombStoneSave_GetMapName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWTombStoneSave.GetSaveTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UFWTombStoneSave::GetSaveTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "GetSaveTime");

	Params::FWTombStoneSave_GetSaveTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWTombStoneSave.PickedUp
// (Final, Native, Public, BlueprintCallable)

void UFWTombStoneSave::PickedUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "PickedUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWTombStoneSave.PlayerDied
// (Final, Native, Public, BlueprintCallable)

void UFWTombStoneSave::PlayerDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "PlayerDied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWTombStoneSave.UpdateCapsuleRadius
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const float&                            NewRadius                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWTombStoneSave::UpdateCapsuleRadius(const float& NewRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "UpdateCapsuleRadius");

	Params::FWTombStoneSave_UpdateCapsuleRadius Parms{};

	Parms.NewRadius = NewRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWTombStoneSave.UpdateLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWTombStoneSave::UpdateLocation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "UpdateLocation");

	Params::FWTombStoneSave_UpdateLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWTombStoneSave.UpdateMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    NewMapName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             DropChance                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   SpawnItems                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   HadDied                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWTombStoneSave::UpdateMap(const class FString& NewMapName, const float DropChance, bool* SpawnItems, bool* HadDied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "UpdateMap");

	Params::FWTombStoneSave_UpdateMap Parms{};

	Parms.NewMapName = std::move(NewMapName);
	Parms.DropChance = DropChance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnItems != nullptr)
		*SpawnItems = Parms.SpawnItems;

	if (HadDied != nullptr)
		*HadDied = Parms.HadDied;
}


// Function ForeverWinter.FWTombStoneSave.UpdateRigBrougtIn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSavedContainer>&   NewCustomContainersUsed                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FSavedFrame>&       NewCustomFramesUsed                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFWTombStoneSave::UpdateRigBrougtIn(const TArray<struct FSavedContainer>& NewCustomContainersUsed, const TArray<struct FSavedFrame>& NewCustomFramesUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "UpdateRigBrougtIn");

	Params::FWTombStoneSave_UpdateRigBrougtIn Parms{};

	Parms.NewCustomContainersUsed = std::move(NewCustomContainersUsed);
	Parms.NewCustomFramesUsed = std::move(NewCustomFramesUsed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWTombStoneSave.UpdateWeaponsBroughtIn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FSavedWeapon>&      NewWeapons                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FSavedItem>&        NewWeaponParts                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFWTombStoneSave::UpdateWeaponsBroughtIn(const TArray<struct FSavedWeapon>& NewWeapons, const TArray<struct FSavedItem>& NewWeaponParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWTombStoneSave", "UpdateWeaponsBroughtIn");

	Params::FWTombStoneSave_UpdateWeaponsBroughtIn Parms{};

	Parms.NewWeapons = std::move(NewWeapons);
	Parms.NewWeaponParts = std::move(NewWeaponParts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.AddBotDeliveredWaterDays
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Days                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bTriggeredInvasion                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::AddBotDeliveredWaterDays(class UFWPersistenceSubsystem* PersistenceSubsystem, const int32 Days, const bool bTriggeredInvasion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "AddBotDeliveredWaterDays");

	Params::FWWaterFunctionLibrary_AddBotDeliveredWaterDays Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;
	Parms.Days = Days;
	Parms.bTriggeredInvasion = bTriggeredInvasion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.AddOnWaterAmountChangedEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TDelegate<void(int32 NewAmount)>& Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::AddOnWaterAmountChangedEvent(const TDelegate<void(int32 NewAmount)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "AddOnWaterAmountChangedEvent");

	Params::FWWaterFunctionLibrary_AddOnWaterAmountChangedEvent Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.AddOnWaterOverflowEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TDelegate<void(class UFWPersistenceSubsystem* Subsystem, int32 WaterBarrelCount)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::AddOnWaterOverflowEvent(const TDelegate<void(class UFWPersistenceSubsystem* Subsystem, int32 WaterBarrelCount)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "AddOnWaterOverflowEvent");

	Params::FWWaterFunctionLibrary_AddOnWaterOverflowEvent Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.AddWater
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Days                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWWaterFunctionLibrary::AddWater(class UFWPersistenceSubsystem* PersistenceSubsystem, const int32 Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "AddWater");

	Params::FWWaterFunctionLibrary_AddWater Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;
	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.BeginWaterDeathFight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Reason                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::BeginWaterDeathFight(class UFWPersistenceSubsystem* PersistenceSubsystem, const struct FGameplayTag& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "BeginWaterDeathFight");

	Params::FWWaterFunctionLibrary_BeginWaterDeathFight Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.CalculateMissionWaterCost
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMapSpawnPoint&            SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWWaterFunctionLibrary::CalculateMissionWaterCost(const struct FMapSpawnPoint& SpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "CalculateMissionWaterCost");

	Params::FWWaterFunctionLibrary_CalculateMissionWaterCost Parms{};

	Parms.SpawnPoint = std::move(SpawnPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.ClearInvasionReason
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::ClearInvasionReason(class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "ClearInvasionReason");

	Params::FWWaterFunctionLibrary_ClearInvasionReason Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.ClearWaterBotDeliveryReport
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::ClearWaterBotDeliveryReport(class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "ClearWaterBotDeliveryReport");

	Params::FWWaterFunctionLibrary_ClearWaterBotDeliveryReport Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.ConvertRealtimeWaterToCurrency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::ConvertRealtimeWaterToCurrency(class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "ConvertRealtimeWaterToCurrency");

	Params::FWWaterFunctionLibrary_ConvertRealtimeWaterToCurrency Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.EndWaterDeathFight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::EndWaterDeathFight(class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "EndWaterDeathFight");

	Params::FWWaterFunctionLibrary_EndWaterDeathFight Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.ExecuteOutOfWaterDataClear
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Reason                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::ExecuteOutOfWaterDataClear(class UFWPersistenceSubsystem* PersistenceSubsystem, const struct FGameplayTag& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "ExecuteOutOfWaterDataClear");

	Params::FWWaterFunctionLibrary_ExecuteOutOfWaterDataClear Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetAvailableWaterCapacity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWWaterFunctionLibrary::GetAvailableWaterCapacity(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetAvailableWaterCapacity");

	Params::FWWaterFunctionLibrary_GetAvailableWaterCapacity Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetInvasionReason
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UFWWaterFunctionLibrary::GetInvasionReason(class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetInvasionReason");

	Params::FWWaterFunctionLibrary_GetInvasionReason Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetLocalRemainingWater
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWWaterFunctionLibrary::GetLocalRemainingWater(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetLocalRemainingWater");

	Params::FWWaterFunctionLibrary_GetLocalRemainingWater Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetMaximumWaterCapacity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWWaterFunctionLibrary::GetMaximumWaterCapacity(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetMaximumWaterCapacity");

	Params::FWWaterFunctionLibrary_GetMaximumWaterCapacity Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetWaterBotDeliveryReport
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UFWWaterFunctionLibrary::GetWaterBotDeliveryReport(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetWaterBotDeliveryReport");

	Params::FWWaterFunctionLibrary_GetWaterBotDeliveryReport Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetWaterCurrency
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCurrencyType                    ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FCurrencyType UFWWaterFunctionLibrary::GetWaterCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetWaterCurrency");

	Params::FWWaterFunctionLibrary_GetWaterCurrency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GetWaterWarningDays
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFWWaterFunctionLibrary::GetWaterWarningDays()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GetWaterWarningDays");

	Params::FWWaterFunctionLibrary_GetWaterWarningDays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.GrantDefaultWaterSupply
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::GrantDefaultWaterSupply(class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "GrantDefaultWaterSupply");

	Params::FWWaterFunctionLibrary_GrantDefaultWaterSupply Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.HasRunOutOfWater
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::HasRunOutOfWater(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "HasRunOutOfWater");

	Params::FWWaterFunctionLibrary_HasRunOutOfWater Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.IsBeingInvaded
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::IsBeingInvaded(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "IsBeingInvaded");

	Params::FWWaterFunctionLibrary_IsBeingInvaded Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.IsInWaterDeathFight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::IsInWaterDeathFight(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "IsInWaterDeathFight");

	Params::FWWaterFunctionLibrary_IsInWaterDeathFight Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.IsWaterStashConverted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::IsWaterStashConverted(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "IsWaterStashConverted");

	Params::FWWaterFunctionLibrary_IsWaterStashConverted Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.SetInvasionReason
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              NewInvasionReason                                      (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::SetInvasionReason(class UFWPersistenceSubsystem* PersistenceSubsystem, const struct FGameplayTag& NewInvasionReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "SetInvasionReason");

	Params::FWWaterFunctionLibrary_SetInvasionReason Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;
	Parms.NewInvasionReason = std::move(NewInvasionReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.SetWaterStashConverted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFWPersistenceSubsystem*          PersistenceSubsystem                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsConverted                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterFunctionLibrary::SetWaterStashConverted(class UFWPersistenceSubsystem* PersistenceSubsystem, const bool bIsConverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "SetWaterStashConverted");

	Params::FWWaterFunctionLibrary_SetWaterStashConverted Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;
	Parms.bIsConverted = bIsConverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterFunctionLibrary.ShouldEnterWaterDeathFight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag*                    Reason                                                 (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::ShouldEnterWaterDeathFight(const class UFWPersistenceSubsystem* PersistenceSubsystem, struct FGameplayTag* Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "ShouldEnterWaterDeathFight");

	Params::FWWaterFunctionLibrary_ShouldEnterWaterDeathFight Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reason != nullptr)
		*Reason = std::move(Parms.Reason);

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterFunctionLibrary.WasInWaterDeathFight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    PersistenceSubsystem                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWaterFunctionLibrary::WasInWaterDeathFight(const class UFWPersistenceSubsystem* PersistenceSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWaterFunctionLibrary", "WasInWaterDeathFight");

	Params::FWWaterFunctionLibrary_WasInWaterDeathFight Parms{};

	Parms.PersistenceSubsystem = PersistenceSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterVault.AddCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FCurrencyDetails&          NewCurrency                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UFWWaterVault::AddCurrency(const struct FCurrencyDetails& NewCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "AddCurrency");

	Params::FWWaterVault_AddCurrency Parms{};

	Parms.NewCurrency = std::move(NewCurrency);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterVault.AddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Item                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterVault::AddItem(const struct FGameplayTag& Item, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "AddItem");

	Params::FWWaterVault_AddItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterVault.GetVaultCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCurrencyDetails                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCurrencyDetails UFWWaterVault::GetVaultCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "GetVaultCurrency");

	Params::FWWaterVault_GetVaultCurrency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterVault.GetVaultItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<struct FGameplayTag, int32>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, int32> UFWWaterVault::GetVaultItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "GetVaultItems");

	Params::FWWaterVault_GetVaultItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWaterVault.InitializeCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FCurrencyDetails&          NewCurrency                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UFWWaterVault::InitializeCurrency(const struct FCurrencyDetails& NewCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "InitializeCurrency");

	Params::FWWaterVault_InitializeCurrency Parms{};

	Parms.NewCurrency = std::move(NewCurrency);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterVault.RemoveCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FCurrencyDetails&          NewCurrency                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UFWWaterVault::RemoveCurrency(const struct FCurrencyDetails& NewCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "RemoveCurrency");

	Params::FWWaterVault_RemoveCurrency Parms{};

	Parms.NewCurrency = std::move(NewCurrency);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWaterVault.RemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Item                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFWWaterVault::RemoveItem(const struct FGameplayTag& Item, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWWaterVault", "RemoveItem");

	Params::FWWaterVault_RemoveItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.FWWeaponExperienceFunctionLibrary.GetWeaponLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryDangly&          WeaponRow                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFWWeaponExperienceFunctionLibrary::GetWeaponLevel(const class UFWPersistenceSubsystem* Subsystem, const struct FInventoryDangly& WeaponRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWeaponExperienceFunctionLibrary", "GetWeaponLevel");

	Params::FWWeaponExperienceFunctionLibrary_GetWeaponLevel Parms{};

	Parms.Subsystem = Subsystem;
	Parms.WeaponRow = std::move(WeaponRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWeaponExperienceFunctionLibrary.GetWeaponLevelAndExperience
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryDangly&          WeaponRow                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  CurrentLevel                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  CurrentXP                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  CurrentLevelXP                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NextLevelXP                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFWWeaponExperienceFunctionLibrary::GetWeaponLevelAndExperience(const class UFWPersistenceSubsystem* Subsystem, const struct FInventoryDangly& WeaponRow, int32* CurrentLevel, int32* CurrentXP, int32* CurrentLevelXP, int32* NextLevelXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWeaponExperienceFunctionLibrary", "GetWeaponLevelAndExperience");

	Params::FWWeaponExperienceFunctionLibrary_GetWeaponLevelAndExperience Parms{};

	Parms.Subsystem = Subsystem;
	Parms.WeaponRow = std::move(WeaponRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentLevel != nullptr)
		*CurrentLevel = Parms.CurrentLevel;

	if (CurrentXP != nullptr)
		*CurrentXP = Parms.CurrentXP;

	if (CurrentLevelXP != nullptr)
		*CurrentLevelXP = Parms.CurrentLevelXP;

	if (NextLevelXP != nullptr)
		*NextLevelXP = Parms.NextLevelXP;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWeaponExperienceFunctionLibrary.GetWeaponLevelLockedParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryDangly&          WeaponRow                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDataTableRowHandle> UFWWeaponExperienceFunctionLibrary::GetWeaponLevelLockedParts(const class UFWPersistenceSubsystem* Subsystem, const struct FInventoryDangly& WeaponRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWeaponExperienceFunctionLibrary", "GetWeaponLevelLockedParts");

	Params::FWWeaponExperienceFunctionLibrary_GetWeaponLevelLockedParts Parms{};

	Parms.Subsystem = Subsystem;
	Parms.WeaponRow = std::move(WeaponRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.FWWeaponExperienceFunctionLibrary.GetWeaponLevelUnlockedParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFWPersistenceSubsystem*    Subsystem                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryDangly&          WeaponRow                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDataTableRowHandle> UFWWeaponExperienceFunctionLibrary::GetWeaponLevelUnlockedParts(const class UFWPersistenceSubsystem* Subsystem, const struct FInventoryDangly& WeaponRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FWWeaponExperienceFunctionLibrary", "GetWeaponLevelUnlockedParts");

	Params::FWWeaponExperienceFunctionLibrary_GetWeaponLevelUnlockedParts Parms{};

	Parms.Subsystem = Subsystem;
	Parms.WeaponRow = std::move(WeaponRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.RareLootHelper.CanDrop
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              RequiredTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URareLootHelper::CanDrop(const struct FGameplayTag& RequiredTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RareLootHelper", "CanDrop");

	Params::RareLootHelper_CanDrop Parms{};

	Parms.RequiredTag = std::move(RequiredTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.AddActiveDangly
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UFWDanglyComponent*               DanglyComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::AddActiveDangly(class UFWDanglyComponent* DanglyComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "AddActiveDangly");

	Params::SBackpackRig_AddActiveDangly Parms{};

	Parms.DanglyComponent = DanglyComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.AddContainer
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FSavedItem>&        ItemDetailQuantity                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       ContainerRow                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UFWRigContainersComponent**       Container                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::AddContainer(const struct FTransform& RelativeTransform, const TArray<struct FSavedItem>& ItemDetailQuantity, const struct FDataTableRowHandle& ContainerRow, class UFWRigContainersComponent** Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "AddContainer");

	Params::SBackpackRig_AddContainer Parms{};

	Parms.RelativeTransform = std::move(RelativeTransform);
	Parms.ItemDetailQuantity = std::move(ItemDetailQuantity);
	Parms.ContainerRow = std::move(ContainerRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Container != nullptr)
		*Container = Parms.Container;
}


// Function ForeverWinter.SBackpackRig.AddMultiDanglyFrame
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FBackpackMultiDangleInfo&  MultiFrameData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFWMultiRigDanglySlot**           OutMultiFrame                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::AddMultiDanglyFrame(const struct FBackpackMultiDangleInfo& MultiFrameData, class UFWMultiRigDanglySlot** OutMultiFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "AddMultiDanglyFrame");

	Params::SBackpackRig_AddMultiDanglyFrame Parms{};

	Parms.MultiFrameData = std::move(MultiFrameData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMultiFrame != nullptr)
		*OutMultiFrame = Parms.OutMultiFrame;
}


// Function ForeverWinter.SBackpackRig.CallDangleLooted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::CallDangleLooted(class AActor* DangleContainer, const class FString& NewContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "CallDangleLooted");

	Params::SBackpackRig_CallDangleLooted Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.CallUpdateDanglePosition
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OldContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::CallUpdateDanglePosition(class AActor* DangleContainer, const class FString& NewContainerSlot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "CallUpdateDanglePosition");

	Params::SBackpackRig_CallUpdateDanglePosition Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.CanFitContainer
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SocketNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FIntPoint&                 SocketSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFWRigContainersComponent>Container                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASBackpackRig::CanFitContainer(int32 SocketNum, const struct FIntPoint& SocketSize, TSubclassOf<class UFWRigContainersComponent> Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "CanFitContainer");

	Params::SBackpackRig_CanFitContainer Parms{};

	Parms.SocketNum = SocketNum;
	Parms.SocketSize = std::move(SocketSize);
	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.CanLootDangle
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              CanLoot                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::CanLootDangle(class AActor* DangleContainer, const bool CanLoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "CanLootDangle");

	Params::SBackpackRig_CanLootDangle Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.CanLoot = CanLoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.ChangeCompatibleAmmoTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FGameplayTag>&      NewCompatibleAmmo                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASBackpackRig::ChangeCompatibleAmmoTypes(const TArray<struct FGameplayTag>& NewCompatibleAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "ChangeCompatibleAmmoTypes");

	Params::SBackpackRig_ChangeCompatibleAmmoTypes Parms{};

	Parms.NewCompatibleAmmo = std::move(NewCompatibleAmmo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.CycleActiveDangly
// (Final, Native, Public, BlueprintCallable)

void ASBackpackRig::CycleActiveDangly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "CycleActiveDangly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.DangleLooted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Initializing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::DangleLooted(class AActor* DangleContainer, const class FString& NewContainerSlot, bool Initializing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "DangleLooted");

	Params::SBackpackRig_DangleLooted Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.Initializing = Initializing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.EndActiveDangly
// (Final, Native, Public, BlueprintCallable)

void ASBackpackRig::EndActiveDangly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "EndActiveDangly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.GatherLootedItems
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UFWTombStoneSave*                 Tombstone                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::GatherLootedItems(class UFWTombStoneSave* Tombstone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GatherLootedItems");

	Params::SBackpackRig_GatherLootedItems Parms{};

	Parms.Tombstone = Tombstone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.GetActiveDangly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFWDanglyComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFWDanglyComponent* ASBackpackRig::GetActiveDangly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetActiveDangly");

	Params::SBackpackRig_GetActiveDangly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetContainerItemsWeight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASBackpackRig::GetContainerItemsWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetContainerItemsWeight");

	Params::SBackpackRig_GetContainerItemsWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetContainers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EItemCategory                           ContainerType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFWRigContainersComponent*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UFWRigContainersComponent*> ASBackpackRig::GetContainers(EItemCategory ContainerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetContainers");

	Params::SBackpackRig_GetContainers Parms{};

	Parms.ContainerType = ContainerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetDangliesWeight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASBackpackRig::GetDangliesWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetDangliesWeight");

	Params::SBackpackRig_GetDangliesWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetExtractedRigData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FBackpackRigDefaults&      RigStartingData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>*     LootItems                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>*     LootDanglies                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>*     ExtractedItems                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDataTableRowHandle>*     ExtractedDanglies                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FBackpackRigDefaults*            RigData                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void ASBackpackRig::GetExtractedRigData(const struct FBackpackRigDefaults& RigStartingData, TArray<struct FDataTableRowHandle>* LootItems, TArray<struct FDataTableRowHandle>* LootDanglies, TArray<struct FDataTableRowHandle>* ExtractedItems, TArray<struct FDataTableRowHandle>* ExtractedDanglies, struct FBackpackRigDefaults* RigData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetExtractedRigData");

	Params::SBackpackRig_GetExtractedRigData Parms{};

	Parms.RigStartingData = std::move(RigStartingData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LootItems != nullptr)
		*LootItems = std::move(Parms.LootItems);

	if (LootDanglies != nullptr)
		*LootDanglies = std::move(Parms.LootDanglies);

	if (ExtractedItems != nullptr)
		*ExtractedItems = std::move(Parms.ExtractedItems);

	if (ExtractedDanglies != nullptr)
		*ExtractedDanglies = std::move(Parms.ExtractedDanglies);

	if (RigData != nullptr)
		*RigData = std::move(Parms.RigData);
}


// Function ForeverWinter.SBackpackRig.GetIsWeaponIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             WeaponIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFWWeaponBase*                    CompareToWeapon                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASBackpackRig::GetIsWeaponIndex(const int32 WeaponIndex, class AFWWeaponBase* CompareToWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetIsWeaponIndex");

	Params::SBackpackRig_GetIsWeaponIndex Parms{};

	Parms.WeaponIndex = WeaponIndex;
	Parms.CompareToWeapon = CompareToWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetLootValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASBackpackRig::GetLootValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetLootValue");

	Params::SBackpackRig_GetLootValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetNextActiveConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDataTableRowHandle ASBackpackRig::GetNextActiveConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetNextActiveConsumable");

	Params::SBackpackRig_GetNextActiveConsumable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetOwnerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASBackpackRig::GetOwnerLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetOwnerLocation");

	Params::SBackpackRig_GetOwnerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetWeaponAmmoCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             WeaponIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  ClipAmmo                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SpareAmmo                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::GetWeaponAmmoCounts(const int32 WeaponIndex, int32* ClipAmmo, int32* SpareAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetWeaponAmmoCounts");

	Params::SBackpackRig_GetWeaponAmmoCounts Parms{};

	Parms.WeaponIndex = WeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClipAmmo != nullptr)
		*ClipAmmo = Parms.ClipAmmo;

	if (SpareAmmo != nullptr)
		*SpareAmmo = Parms.SpareAmmo;
}


// Function ForeverWinter.SBackpackRig.GetWeapons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class AFWWeaponBase*>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class AFWWeaponBase*> ASBackpackRig::GetWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetWeapons");

	Params::SBackpackRig_GetWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.GetWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASBackpackRig::GetWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetWeight");

	Params::SBackpackRig_GetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.HasLootedUniqueDangly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASBackpackRig::HasLootedUniqueDangly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "HasLootedUniqueDangly");

	Params::SBackpackRig_HasLootedUniqueDangly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SBackpackRig.InitialiseContainers
// (Final, Native, Protected, BlueprintCallable)

void ASBackpackRig::InitialiseContainers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "InitialiseContainers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.LoadFrame
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ASBackpackRig::LoadFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "LoadFrame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnActiveConsumableChanged
// (Final, Native, Public)

void ASBackpackRig::OnActiveConsumableChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnActiveConsumableChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_ActiveDanglyUpdated
// (Final, Native, Protected, BlueprintCallable)

void ASBackpackRig::OnRep_ActiveDanglyUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_ActiveDanglyUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_AmmoUpdated
// (Final, Native, Protected)

void ASBackpackRig::OnRep_AmmoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_AmmoUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_ConsumablesUpdated
// (Final, Native, Protected)

void ASBackpackRig::OnRep_ConsumablesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_ConsumablesUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_ContainersUpdated
// (Final, Native, Protected)

void ASBackpackRig::OnRep_ContainersUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_ContainersUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_DanglesUpdated
// (Final, Native, Protected)

void ASBackpackRig::OnRep_DanglesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_DanglesUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_FramesUpdated
// (Final, Native, Protected, BlueprintCallable)

void ASBackpackRig::OnRep_FramesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_FramesUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_OwnerSet
// (Final, Native, Protected)

void ASBackpackRig::OnRep_OwnerSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_OwnerSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OnRep_RigWeaponsUpdated
// (Final, Native, Protected)

void ASBackpackRig::OnRep_RigWeaponsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OnRep_RigWeaponsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.OwningPlayerDied
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFWTombStoneSave*                 Tombstone                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceSave                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::OwningPlayerDied(class UFWTombStoneSave* Tombstone, bool ForceSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "OwningPlayerDied");

	Params::SBackpackRig_OwningPlayerDied Parms{};

	Parms.Tombstone = Tombstone;
	Parms.ForceSave = ForceSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.PlayDangleLooted
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const class AActor*                     Dangly                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class USoundCue>&  DropSound                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::PlayDangleLooted(const class AActor* Dangly, const struct FVector& Offset, const TSoftObjectPtr<class USoundCue>& DropSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "PlayDangleLooted");

	Params::SBackpackRig_PlayDangleLooted Parms{};

	Parms.Dangly = Dangly;
	Parms.Offset = std::move(Offset);
	Parms.DropSound = DropSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.PlayRemoveDangle
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const class AActor*                     Dangly                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class USoundCue>&  DropSound                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::PlayRemoveDangle(const class AActor* Dangly, const struct FVector& Offset, const TSoftObjectPtr<class USoundCue>& DropSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "PlayRemoveDangle");

	Params::SBackpackRig_PlayRemoveDangle Parms{};

	Parms.Dangly = Dangly;
	Parms.Offset = std::move(Offset);
	Parms.DropSound = DropSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RecalculateWeight
// (Final, Native, Protected, BlueprintCallable)

void ASBackpackRig::RecalculateWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RecalculateWeight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RemoveDangle
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    ContainerSlot                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RemoveDangle(const class FString& ContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RemoveDangle");

	Params::SBackpackRig_RemoveDangle Parms{};

	Parms.ContainerSlot = std::move(ContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RemoveDangleClientExtra
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    ContainerSlot                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RemoveDangleClientExtra(const class FString& ContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RemoveDangleClientExtra");

	Params::SBackpackRig_RemoveDangleClientExtra Parms{};

	Parms.ContainerSlot = std::move(ContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestDangleSwap
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OldContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RequestDangleSwap(class AActor* DangleContainer, const class FString& NewContainerSlot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestDangleSwap");

	Params::SBackpackRig_RequestDangleSwap Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestDropAllItems
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ASBackpackRig::RequestDropAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestDropAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestDropAllItemsWithCurrencies
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const TArray<struct FCurrencyDetails>&  Currencies                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASBackpackRig::RequestDropAllItemsWithCurrencies(const TArray<struct FCurrencyDetails>& Currencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestDropAllItemsWithCurrencies");

	Params::SBackpackRig_RequestDropAllItemsWithCurrencies Parms{};

	Parms.Currencies = std::move(Currencies);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestLootAllContainerItems
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// int32                                   RevealedCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASInventoryContainer*             LootContainer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RequestLootAllContainerItems(int32 RevealedCount, class ASInventoryContainer* LootContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestLootAllContainerItems");

	Params::SBackpackRig_RequestLootAllContainerItems Parms{};

	Parms.RevealedCount = RevealedCount;
	Parms.LootContainer = LootContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestLootDangle
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RequestLootDangle(class AActor* DangleContainer, const class FString& NewContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestLootDangle");

	Params::SBackpackRig_RequestLootDangle Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestRemoveDangle
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class FString&                    ContainerSlot                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RequestRemoveDangle(const class FString& ContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestRemoveDangle");

	Params::SBackpackRig_RequestRemoveDangle Parms{};

	Parms.ContainerSlot = std::move(ContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.RequestReplaceDangle
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::RequestReplaceDangle(class AActor* DangleContainer, const class FString& NewContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "RequestReplaceDangle");

	Params::SBackpackRig_RequestReplaceDangle Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.SelectActiveConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       ConsumableItem                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASBackpackRig::SelectActiveConsumable(const struct FDataTableRowHandle& ConsumableItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "SelectActiveConsumable");

	Params::SBackpackRig_SelectActiveConsumable Parms{};

	Parms.ConsumableItem = std::move(ConsumableItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.SelectActiveDangly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             DanglyIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::SelectActiveDangly(const int32 DanglyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "SelectActiveDangly");

	Params::SBackpackRig_SelectActiveDangly Parms{};

	Parms.DanglyIndex = DanglyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.SetDetails
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FBackpackRigDefaults&      Details                                                (Parm, NativeAccessSpecifierPublic)

void ASBackpackRig::SetDetails(const struct FBackpackRigDefaults& Details)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "SetDetails");

	Params::SBackpackRig_SetDetails Parms{};

	Parms.Details = std::move(Details);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.SetOwningPlayerCharacter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           PlayerCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::SetOwningPlayerCharacter(class AFWGamePlayerCharacter* PlayerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "SetOwningPlayerCharacter");

	Params::SBackpackRig_SetOwningPlayerCharacter Parms{};

	Parms.PlayerCharacter = PlayerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.UpdateDanglePosition
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DangleContainer                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OldContainerSlot                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASBackpackRig::UpdateDanglePosition(class AActor* DangleContainer, const class FString& NewContainerSlot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "UpdateDanglePosition");

	Params::SBackpackRig_UpdateDanglePosition Parms{};

	Parms.DangleContainer = DangleContainer;
	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.UpdateValue
// (Final, Native, Public, BlueprintCallable)

void ASBackpackRig::UpdateValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "UpdateValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.UseActiveConsumable
// (Final, Native, Public, BlueprintCallable)

void ASBackpackRig::UseActiveConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "UseActiveConsumable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.UseActiveDangly
// (Final, Native, Public, BlueprintCallable)

void ASBackpackRig::UseActiveDangly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "UseActiveDangly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SBackpackRig.GetAmmoTypes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              AmmoType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<struct FGameplayTag>               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<struct FGameplayTag> ASBackpackRig::GetAmmoTypes(const struct FGameplayTag& AmmoType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBackpackRig", "GetAmmoTypes");

	Params::SBackpackRig_GetAmmoTypes Parms{};

	Parms.AmmoType = std::move(AmmoType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCharacterAnimInstance.EnableRootMotionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCharacterAnimInstance::EnableRootMotionMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCharacterAnimInstance", "EnableRootMotionMode");

	Params::SCharacterAnimInstance_EnableRootMotionMode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.OnDropMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void USCarryObjectComponent::OnDropMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "OnDropMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.OnPickupMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           FocusActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCarryObjectComponent::OnPickupMulticast(class AActor* FocusActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "OnPickupMulticast");

	Params::SCarryObjectComponent_OnPickupMulticast Parms{};

	Parms.FocusActor = FocusActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.OnRotateMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   DirectionYaw                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DirectionRoll                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCarryObjectComponent::OnRotateMulticast(float DirectionYaw, float DirectionRoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "OnRotateMulticast");

	Params::SCarryObjectComponent_OnRotateMulticast Parms{};

	Parms.DirectionYaw = DirectionYaw;
	Parms.DirectionRoll = DirectionRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.ServerDrop
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void USCarryObjectComponent::ServerDrop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "ServerDrop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.ServerPickup
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void USCarryObjectComponent::ServerPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "ServerPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.ServerRotate
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   DirectionYaw                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DirectionRoll                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCarryObjectComponent::ServerRotate(float DirectionYaw, float DirectionRoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "ServerRotate");

	Params::SCarryObjectComponent_ServerRotate Parms{};

	Parms.DirectionYaw = DirectionYaw;
	Parms.DirectionRoll = DirectionRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCarryObjectComponent.ServerThrow
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void USCarryObjectComponent::ServerThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCarryObjectComponent", "ServerThrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCharacterUsableActorComponent.ServerBeginUse
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class ASUsableActor*                    UseActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCharacterUsableActorComponent::ServerBeginUse(class ASUsableActor* UseActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCharacterUsableActorComponent", "ServerBeginUse");

	Params::SCharacterUsableActorComponent_ServerBeginUse Parms{};

	Parms.UseActor = UseActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCharacterUsableActorComponent.ServerEndUse
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void USCharacterUsableActorComponent::ServerEndUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCharacterUsableActorComponent", "ServerEndUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCharacterUsableActorComponent.GetInteractProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USCharacterUsableActorComponent::GetInteractProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCharacterUsableActorComponent", "GetInteractProgress");

	Params::SCharacterUsableActorComponent_GetInteractProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCharacterUsableActorComponent.ShowProgressBar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCharacterUsableActorComponent::ShowProgressBar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCharacterUsableActorComponent", "ShowProgressBar");

	Params::SCharacterUsableActorComponent_ShowProgressBar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SCheatManager.ForceRestartPlayer
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCheatManager::ForceRestartPlayer(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCheatManager", "ForceRestartPlayer");

	Params::SCheatManager_ForceRestartPlayer Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCheatManager.SetRelationship
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Relationship                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCheatManager::SetRelationship(int32 Relationship)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCheatManager", "SetRelationship");

	Params::SCheatManager_SetRelationship Parms{};

	Parms.Relationship = Relationship;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCheatManager.SpawnExplosiveShotgun
// (Final, Exec, Native, Public)

void USCheatManager::SpawnExplosiveShotgun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCheatManager", "SpawnExplosiveShotgun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SCheatManager.SpawnSniperRifle
// (Final, Exec, Native, Public)

void USCheatManager::SpawnSniperRifle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCheatManager", "SpawnSniperRifle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ScreenshotFunctionLib.ConvertBytesToTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FScreenshot&               Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UScreenshotFunctionLib::ConvertBytesToTexture(const struct FScreenshot& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenshotFunctionLib", "ConvertBytesToTexture");

	Params::ScreenshotFunctionLib_ConvertBytesToTexture Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.ScreenshotFunctionLib.ResetCapturingScreenshot
// (Final, Native, Static, Public, BlueprintCallable)

void UScreenshotFunctionLib::ResetCapturingScreenshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenshotFunctionLib", "ResetCapturingScreenshot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.ScreenshotFunctionLib.TakeScreenshot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector4&                  NewFrame                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToFile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SaveLocation                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FIntPoint&                 DesiredSizeOutput                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const struct FScreenshot& Image, class UTexture2D* Texture)>&ScreenshotDelegate                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenshotFunctionLib::TakeScreenshot(const struct FVector4& NewFrame, bool SaveToFile, const class FString& SaveLocation, const struct FIntPoint& DesiredSizeOutput, const TDelegate<void(const struct FScreenshot& Image, class UTexture2D* Texture)>& ScreenshotDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenshotFunctionLib", "TakeScreenshot");

	Params::ScreenshotFunctionLib_TakeScreenshot Parms{};

	Parms.NewFrame = std::move(NewFrame);
	Parms.SaveToFile = SaveToFile;
	Parms.SaveLocation = std::move(SaveLocation);
	Parms.DesiredSizeOutput = std::move(DesiredSizeOutput);
	Parms.ScreenshotDelegate = ScreenshotDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SExplosiveBarrelActor.SimulateExplosion
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ASExplosiveBarrelActor::SimulateExplosion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SExplosiveBarrelActor", "SimulateExplosion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SFL_CoreFunctions.CalculateHitAngleOnActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Instigator                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     HitActor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USFL_CoreFunctions::CalculateHitAngleOnActor(const class AActor* Instigator, const class AActor* HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_CoreFunctions", "CalculateHitAngleOnActor");

	Params::SFL_CoreFunctions_CalculateHitAngleOnActor Parms{};

	Parms.Instigator = Instigator;
	Parms.HitActor = HitActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFL_CoreFunctions.CalculateProjectileRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   PropellantForce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceRatio                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USFL_CoreFunctions::CalculateProjectileRange(float PropellantForce, float ForceRatio, float Mass, float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_CoreFunctions", "CalculateProjectileRange");

	Params::SFL_CoreFunctions_CalculateProjectileRange Parms{};

	Parms.PropellantForce = PropellantForce;
	Parms.ForceRatio = ForceRatio;
	Parms.Mass = Mass;
	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFL_CoreFunctions.CalculateProjectileSpeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   PropellantForce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceRatio                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USFL_CoreFunctions::CalculateProjectileSpeed(float PropellantForce, float ForceRatio, float Mass, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_CoreFunctions", "CalculateProjectileSpeed");

	Params::SFL_CoreFunctions_CalculateProjectileSpeed Parms{};

	Parms.PropellantForce = PropellantForce;
	Parms.ForceRatio = ForceRatio;
	Parms.Mass = Mass;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFL_CoreFunctions.GetShotGunSprayAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   MuzzleLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USFL_CoreFunctions::GetShotGunSprayAngle(const struct FVector& MuzzleLocation, float MaximumAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_CoreFunctions", "GetShotGunSprayAngle");

	Params::SFL_CoreFunctions_GetShotGunSprayAngle Parms{};

	Parms.MuzzleLocation = std::move(MuzzleLocation);
	Parms.MaximumAngle = MaximumAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFL_CoreFunctions.IsPlayingInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USFL_CoreFunctions::IsPlayingInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_CoreFunctions", "IsPlayingInEditor");

	Params::SFL_CoreFunctions_IsPlayingInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFL_JsonData.ReadStringFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutInfoMessage                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USFL_JsonData::ReadStringFromFile(const class FString& FilePath, bool* bOutSuccess, class FString* OutInfoMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_JsonData", "ReadStringFromFile");

	Params::SFL_JsonData_ReadStringFromFile Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	if (OutInfoMessage != nullptr)
		*OutInfoMessage = std::move(Parms.OutInfoMessage);

	return Parms.ReturnValue;
}


// Function ForeverWinter.SFL_JsonData.WriteStringToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutInfoMessage                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USFL_JsonData::WriteStringToFile(const class FString& FilePath, const class FString& String, bool* bOutSuccess, class FString* OutInfoMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SFL_JsonData", "WriteStringToFile");

	Params::SFL_JsonData_WriteStringToFile Parms{};

	Parms.FilePath = std::move(FilePath);
	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	if (OutInfoMessage != nullptr)
		*OutInfoMessage = std::move(Parms.OutInfoMessage);
}


// Function ForeverWinter.SGameInstance.GetDropContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ASInventoryContainer> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ASInventoryContainer> USGameInstance::GetDropContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SGameInstance", "GetDropContainer");

	Params::SGameInstance_GetDropContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SGameInstance.GetItemClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AFWInventoryItem>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AFWInventoryItem> USGameInstance::GetItemClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SGameInstance", "GetItemClass");

	Params::SGameInstance_GetItemClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SHeadMountedLight.OnRep_IsLightVisible
// (Final, Native, Protected)

void ASHeadMountedLight::OnRep_IsLightVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SHeadMountedLight", "OnRep_IsLightVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SHeadMountedLight.ServerToggleLight
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ASHeadMountedLight::ServerToggleLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SHeadMountedLight", "ServerToggleLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInterpTextBlock.InterpolateToValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InterpTo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USInterpTextBlock::InterpolateToValue(float InterpTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInterpTextBlock", "InterpolateToValue");

	Params::SInterpTextBlock_InterpolateToValue Parms{};

	Parms.InterpTo = InterpTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInterpTextBlock.JumpToValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USInterpTextBlock::JumpToValue(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInterpTextBlock", "JumpToValue");

	Params::SInterpTextBlock_JumpToValue Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.AddItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FContainerItem&            Item                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASInventoryContainer::AddItem(const struct FContainerItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "AddItem");

	Params::SInventoryContainer_AddItem Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.CloseContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::CloseContainer(class AFWGamePlayerCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "CloseContainer");

	Params::SInventoryContainer_CloseContainer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.ContainerOpenStatusChanged
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::ContainerOpenStatusChanged(class AFWGamePlayerCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "ContainerOpenStatusChanged");

	Params::SInventoryContainer_ContainerOpenStatusChanged Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.EnableLooting
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::EnableLooting(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "EnableLooting");

	Params::SInventoryContainer_EnableLooting Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.GetContainerDetails
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInventoryContainer              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryContainer ASInventoryContainer::GetContainerDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetContainerDetails");

	Params::SInventoryContainer_GetContainerDetails Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetContainerLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASInventoryContainer::GetContainerLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetContainerLocked");

	Params::SInventoryContainer_GetContainerLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetContainerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ASInventoryContainer::GetContainerName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetContainerName");

	Params::SInventoryContainer_GetContainerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetContainerOpened
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASInventoryContainer::GetContainerOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetContainerOpened");

	Params::SInventoryContainer_GetContainerOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetContainerSlotsSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint ASInventoryContainer::GetContainerSlotsSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetContainerSlotsSize");

	Params::SInventoryContainer_GetContainerSlotsSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FContainerItem                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FContainerItem ASInventoryContainer::GetItem(int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetItem");

	Params::SInventoryContainer_GetItem Parms{};

	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetItemLootTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASInventoryContainer::GetItemLootTime(int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetItemLootTime");

	Params::SInventoryContainer_GetItemLootTime Parms{};

	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetItemsToSearch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class AFWGamePlayerCharacter*     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FContainerItem>*          Items                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ASInventoryContainer::GetItemsToSearch(const class AFWGamePlayerCharacter* Player, TArray<struct FContainerItem>* Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetItemsToSearch");

	Params::SInventoryContainer_GetItemsToSearch Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Items != nullptr)
		*Items = std::move(Parms.Items);
}


// Function ForeverWinter.SInventoryContainer.GetLootPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASInventoryContainer::GetLootPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetLootPosition");

	Params::SInventoryContainer_GetLootPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetLootRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASInventoryContainer::GetLootRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetLootRange");

	Params::SInventoryContainer_GetLootRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetLootTimer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASInventoryContainer::GetLootTimer(class AFWGamePlayerCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetLootTimer");

	Params::SInventoryContainer_GetLootTimer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SInventoryContainer.GetSearchedItems
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class AFWGamePlayerCharacter*     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FContainerItem>*          Items                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ASInventoryContainer::GetSearchedItems(const class AFWGamePlayerCharacter* Player, TArray<struct FContainerItem>* Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "GetSearchedItems");

	Params::SInventoryContainer_GetSearchedItems Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Items != nullptr)
		*Items = std::move(Parms.Items);
}


// Function ForeverWinter.SInventoryContainer.InitializeContainerStats
// (Final, Native, Protected, BlueprintCallable)

void ASInventoryContainer::InitializeContainerStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "InitializeContainerStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.InitializeInventoryLocation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ContainerOwner                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::InitializeInventoryLocation(class AActor* ContainerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "InitializeInventoryLocation");

	Params::SInventoryContainer_InitializeInventoryLocation Parms{};

	Parms.ContainerOwner = ContainerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.LockContainer
// (Final, Native, Public, BlueprintCallable)

void ASInventoryContainer::LockContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "LockContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.OnRep_ContainerOpened
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ASInventoryContainer::OnRep_ContainerOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "OnRep_ContainerOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.OnRep_ContainerUnlocked
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ASInventoryContainer::OnRep_ContainerUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "OnRep_ContainerUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.OpenContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::OpenContainer(class AFWGamePlayerCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "OpenContainer");

	Params::SInventoryContainer_OpenContainer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.RandomContainerItems
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       RandomItemsRow                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASInventoryContainer::RandomContainerItems(const struct FDataTableRowHandle& RandomItemsRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "RandomContainerItems");

	Params::SInventoryContainer_RandomContainerItems Parms{};

	Parms.RandomItemsRow = std::move(RandomItemsRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.RequestLootCurrencyFromContainer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class AFWGamePlayerCharacter*     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::RequestLootCurrencyFromContainer(const class AFWGamePlayerCharacter* Player, int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "RequestLootCurrencyFromContainer");

	Params::SInventoryContainer_RequestLootCurrencyFromContainer Parms{};

	Parms.Player = Player;
	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.RequestLootFromContainer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class AFWGamePlayerCharacter*     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFWRigContainersComponent*        ToContainer                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::RequestLootFromContainer(const class AFWGamePlayerCharacter* Player, int32 ItemIndex, class UFWRigContainersComponent* ToContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "RequestLootFromContainer");

	Params::SInventoryContainer_RequestLootFromContainer Parms{};

	Parms.Player = Player;
	Parms.ItemIndex = ItemIndex;
	Parms.ToContainer = ToContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.RequestOpenContainer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class AFWGamePlayerCharacter*     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::RequestOpenContainer(const class AFWGamePlayerCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "RequestOpenContainer");

	Params::SInventoryContainer_RequestOpenContainer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.SetContainerOpened
// (Final, Native, Public, BlueprintCallable)

void ASInventoryContainer::SetContainerOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "SetContainerOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.SoftRemoveItem
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASInventoryContainer::SoftRemoveItem(int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "SoftRemoveItem");

	Params::SInventoryContainer_SoftRemoveItem Parms{};

	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.SpawnContainerItems
// (Final, Native, Protected, BlueprintCallable)

void ASInventoryContainer::SpawnContainerItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "SpawnContainerItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.TryAddRareLoot
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       RandomItemsRow                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASInventoryContainer::TryAddRareLoot(const struct FDataTableRowHandle& RandomItemsRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "TryAddRareLoot");

	Params::SInventoryContainer_TryAddRareLoot Parms{};

	Parms.RandomItemsRow = std::move(RandomItemsRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SInventoryContainer.UnlockContainer
// (Final, Native, Public, BlueprintCallable)

void ASInventoryContainer::UnlockContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SInventoryContainer", "UnlockContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SItemTooltipWidget.GetRootActor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* USItemTooltipWidget::GetRootActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SItemTooltipWidget", "GetRootActor");

	Params::SItemTooltipWidget_GetRootActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SItemTooltipWidget.GetTooltipText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USItemTooltipWidget::GetTooltipText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SItemTooltipWidget", "GetTooltipText");

	Params::SItemTooltipWidget_GetTooltipText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SObjectiveManager.ActivateObjective
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASObjectiveManager::ActivateObjective(EObjectiveID ObjectiveID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "ActivateObjective");

	Params::SObjectiveManager_ActivateObjective Parms{};

	Parms.ObjectiveID = ObjectiveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SObjectiveManager.CompleteObjective
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumStepsCompleted                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASObjectiveManager::CompleteObjective(EObjectiveID ObjectiveID, int32 NumStepsCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "CompleteObjective");

	Params::SObjectiveManager_CompleteObjective Parms{};

	Parms.ObjectiveID = ObjectiveID;
	Parms.NumStepsCompleted = NumStepsCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SObjectiveManager.DeactivateObjective
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASObjectiveManager::DeactivateObjective(EObjectiveID ObjectiveID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "DeactivateObjective");

	Params::SObjectiveManager_DeactivateObjective Parms{};

	Parms.ObjectiveID = ObjectiveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SObjectiveManager.OnRep_ActiveObjectives
// (Native, Public)

void ASObjectiveManager::OnRep_ActiveObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "OnRep_ActiveObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SObjectiveManager.TriggerObjectiveTargetUpdated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          UpdatedTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASObjectiveManager::TriggerObjectiveTargetUpdated(EObjectiveID ObjectiveID, class UObject* UpdatedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "TriggerObjectiveTargetUpdated");

	Params::SObjectiveManager_TriggerObjectiveTargetUpdated Parms{};

	Parms.ObjectiveID = ObjectiveID;
	Parms.UpdatedTarget = UpdatedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SObjectiveManager.GetNumStepsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASObjectiveManager::GetNumStepsCompleted(EObjectiveID ObjectiveID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "GetNumStepsCompleted");

	Params::SObjectiveManager_GetNumStepsCompleted Parms{};

	Parms.ObjectiveID = ObjectiveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SObjectiveManager.GetObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectiveInfo*                  out_ObjectiveInfo                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASObjectiveManager::GetObjective(EObjectiveID ObjectiveID, struct FObjectiveInfo* out_ObjectiveInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "GetObjective");

	Params::SObjectiveManager_GetObjective Parms{};

	Parms.ObjectiveID = ObjectiveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_ObjectiveInfo != nullptr)
		*out_ObjectiveInfo = std::move(Parms.out_ObjectiveInfo);

	return Parms.ReturnValue;
}


// Function ForeverWinter.SObjectiveManager.GetObjectives
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FObjectiveInfo>*          out_Objectives                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ASObjectiveManager::GetObjectives(TArray<struct FObjectiveInfo>* out_Objectives) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "GetObjectives");

	Params::SObjectiveManager_GetObjectives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_Objectives != nullptr)
		*out_Objectives = std::move(Parms.out_Objectives);
}


// Function ForeverWinter.SObjectiveManager.IsActiveObjective
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObjectiveID                            IDToCheck                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASObjectiveManager::IsActiveObjective(EObjectiveID IDToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "IsActiveObjective");

	Params::SObjectiveManager_IsActiveObjective Parms{};

	Parms.IDToCheck = IDToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SObjectiveManager.IsObjectiveCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObjectiveID                            ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASObjectiveManager::IsObjectiveCompleted(EObjectiveID ObjectiveID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SObjectiveManager", "IsObjectiveCompleted");

	Params::SObjectiveManager_IsObjectiveCompleted Parms{};

	Parms.ObjectiveID = ObjectiveID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SProjectilePayloadComponent.SimulateDetonation
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FHitResult&                Impact                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USProjectilePayloadComponent::SimulateDetonation(const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SProjectilePayloadComponent", "SimulateDetonation");

	Params::SProjectilePayloadComponent_SimulateDetonation Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SPrimaryPod.OnRep_ShieldPower
// (Final, Native, Protected)

void ASPrimaryPod::OnRep_ShieldPower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SPrimaryPod", "OnRep_ShieldPower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SPrimaryPod.GetMaxHitpoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASPrimaryPod::GetMaxHitpoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SPrimaryPod", "GetMaxHitpoints");

	Params::SPrimaryPod_GetMaxHitpoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SPrimaryPod.GetMaxShieldPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASPrimaryPod::GetMaxShieldPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SPrimaryPod", "GetMaxShieldPower");

	Params::SPrimaryPod_GetMaxShieldPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SquadSpawnerBase.DelayedSpawning
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DelayAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SquadMemberIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnAttemptCounter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquadSpawnerBase::DelayedSpawning(float DelayAmount, int32 SquadMemberIndex, int32 SpawnAttemptCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadSpawnerBase", "DelayedSpawning");

	Params::SquadSpawnerBase_DelayedSpawning Parms{};

	Parms.DelayAmount = DelayAmount;
	Parms.SquadMemberIndex = SquadMemberIndex;
	Parms.SpawnAttemptCounter = SpawnAttemptCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SquadSpawnerBase.OnSquadMemberDeath
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AFWGameAICharacter*               BaseBot                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquadSpawnerBase::OnSquadMemberDeath(class AFWGameAICharacter* BaseBot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadSpawnerBase", "OnSquadMemberDeath");

	Params::SquadSpawnerBase_OnSquadMemberDeath Parms{};

	Parms.BaseBot = BaseBot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SquadSpawnerBase.RespawnSquadMember
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGameAICharacter*               InBaseBot                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquadSpawnerBase::RespawnSquadMember(class AFWGameAICharacter* InBaseBot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadSpawnerBase", "RespawnSquadMember");

	Params::SquadSpawnerBase_RespawnSquadMember Parms{};

	Parms.InBaseBot = InBaseBot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ForeverWinter.SquadSpawnerBase.SpawnSquadMember
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SquadMemberIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnAttemptCounter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquadSpawnerBase::SpawnSquadMember(int32 SquadMemberIndex, int32 SpawnAttemptCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadSpawnerBase", "SpawnSquadMember");

	Params::SquadSpawnerBase_SpawnSquadMember Parms{};

	Parms.SquadMemberIndex = SquadMemberIndex;
	Parms.SpawnAttemptCounter = SpawnAttemptCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.STankProjectile.OnProjectileHit
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASTankProjectile::OnProjectileHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("STankProjectile", "OnProjectileHit");

	Params::STankProjectile_OnProjectileHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SUsableActor.OnEndUse
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASUsableActor::OnEndUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SUsableActor", "OnEndUse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ForeverWinter.SUsableActor.OnUsed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            InstigatorPawn                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASUsableActor::OnUsed(class APawn* InstigatorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SUsableActor", "OnUsed");

	Params::SUsableActor_OnUsed Parms{};

	Parms.InstigatorPawn = InstigatorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ForeverWinter.SUsableActor.CanUse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASUsableActor::CanUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SUsableActor", "CanUse");

	Params::SUsableActor_CanUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.SUsableActor.GetMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ASUsableActor::GetMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SUsableActor", "GetMeshComponent");

	Params::SUsableActor_GetMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.TunnelsSubsystem.GetLightingIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TunnelIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTunnelsSubsystem::GetLightingIndex(int32 TunnelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TunnelsSubsystem", "GetLightingIndex");

	Params::TunnelsSubsystem_GetLightingIndex Parms{};

	Parms.TunnelIndex = TunnelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.TunnelsSubsystem.GetTunnelMap
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   TunnelIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UTunnelsSubsystem::GetTunnelMap(int32 TunnelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TunnelsSubsystem", "GetTunnelMap");

	Params::TunnelsSubsystem_GetTunnelMap Parms{};

	Parms.TunnelIndex = TunnelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.TunnelsSubsystem.IsMapLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTunnelsSubsystem::IsMapLocked(const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TunnelsSubsystem", "IsMapLocked");

	Params::TunnelsSubsystem_IsMapLocked Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.TunnelsSubsystem.GetTunnelIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTunnelsSubsystem::GetTunnelIndex(const class FString& Map) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TunnelsSubsystem", "GetTunnelIndex");

	Params::TunnelsSubsystem_GetTunnelIndex Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ForeverWinter.TunnelsSubsystem.IsTunnelMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTunnelsSubsystem::IsTunnelMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TunnelsSubsystem", "IsTunnelMap");

	Params::TunnelsSubsystem_IsTunnelMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

