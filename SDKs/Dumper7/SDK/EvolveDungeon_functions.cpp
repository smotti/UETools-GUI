#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EvolveDungeon

#include "Basic.hpp"

#include "EvolveDungeon_classes.hpp"
#include "EvolveDungeon_parameters.hpp"


namespace SDK
{

// Function EvolveDungeon.DungeonActor.EnableMapVariants
// (Final, Native, Public)

void ADungeonActor::EnableMapVariants()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonActor", "EnableMapVariants");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonActor.ShowDungeonInfo
// (Final, Exec, Native, Public)

void ADungeonActor::ShowDungeonInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonActor", "ShowDungeonInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonBarrierInterface.Lock
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IDungeonBarrierInterface::Lock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DungeonBarrierInterface", "Lock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonBarrierInterface.Unlock
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IDungeonBarrierInterface::Unlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DungeonBarrierInterface", "Unlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.CloseConnection
// (Final, Native, Public)

void ADungeonConnectionActor::CloseConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "CloseConnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.CloseDoor
// (Final, Native, Public, BlueprintCallable)

void ADungeonConnectionActor::CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "CloseDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.ConnectArea
// (Final, Native, Public)

void ADungeonConnectionActor::ConnectArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "ConnectArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.ConnectConnector
// (Final, Native, Public)

void ADungeonConnectionActor::ConnectConnector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "ConnectConnector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.OnCloseDoor
// (Event, Public, BlueprintEvent)

void ADungeonConnectionActor::OnCloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "OnCloseDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EvolveDungeon.DungeonConnectionActor.OnOpenDoor
// (Event, Public, BlueprintEvent)

void ADungeonConnectionActor::OnOpenDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "OnOpenDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EvolveDungeon.DungeonConnectionActor.OpenDoor
// (Final, Native, Public, BlueprintCallable)

void ADungeonConnectionActor::OpenDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "OpenDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.RotateConnection
// (Final, Native, Public)

void ADungeonConnectionActor::RotateConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "RotateConnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.SwapWithArea
// (Final, Native, Public)

void ADungeonConnectionActor::SwapWithArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "SwapWithArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.SwapWithConnector
// (Final, Native, Public)

void ADungeonConnectionActor::SwapWithConnector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "SwapWithConnector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonConnectionActor.IsConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADungeonConnectionActor::IsConnected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonConnectionActor", "IsConnected");

	Params::DungeonConnectionActor_IsConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevel.AddConnection
// (Final, Native, Public)
// Parameters:
// class ADungeonConnectionActor*          connectionActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevel::AddConnection(class ADungeonConnectionActor* connectionActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevel", "AddConnection");

	Params::DungeonLevel_AddConnection Parms{};

	Parms.connectionActor = connectionActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevel.UpdateLevel
// (Final, Native, Public)

void UDungeonLevel::UpdateLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevel", "UpdateLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonLevel.GetConnection
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const class FString&                    ConnectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDungeonConnectionInfo*          ConnectionInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevel::GetConnection(const class FString& ConnectionName, struct FDungeonConnectionInfo* ConnectionInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevel", "GetConnection");

	Params::DungeonLevel_GetConnection Parms{};

	Parms.ConnectionName = std::move(ConnectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ConnectionInfo != nullptr)
		*ConnectionInfo = std::move(Parms.ConnectionInfo);

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevel.GetConnections
// (Final, Native, Public, Const)
// Parameters:
// EDungeonConnectionType                  ConnectionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDungeonConnectionInfo>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDungeonConnectionInfo> UDungeonLevel::GetConnections(EDungeonConnectionType ConnectionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevel", "GetConnections");

	Params::DungeonLevel_GetConnections Parms{};

	Parms.ConnectionType = ConnectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevel.HasConnection
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    ConnectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevel::HasConnection(const class FString& ConnectionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevel", "HasConnection");

	Params::DungeonLevel_HasConnection Parms{};

	Parms.ConnectionName = std::move(ConnectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevelInstance.GetWorldTransform
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDungeonLevelInstance::GetWorldTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "GetWorldTransform");

	Params::DungeonLevelInstance_GetWorldTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevelInstance.InLevelBounds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevelInstance::InLevelBounds(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "InLevelBounds");

	Params::DungeonLevelInstance_InLevelBounds Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevelInstance.LoadLevel
// (Final, Native, Public)

void UDungeonLevelInstance::LoadLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "LoadLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonLevelInstance.OnMapLoaded
// (Final, Native, Private)

void UDungeonLevelInstance::OnMapLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "OnMapLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonLevelInstance.SetWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FTransform&                NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonLevelInstance::SetWorldTransform(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "SetWorldTransform");

	Params::DungeonLevelInstance_SetWorldTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonLevelInstance.UnloadLevel
// (Final, Native, Public)
// Parameters:
// bool                                    shouldUnloadPersistent                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonLevelInstance::UnloadLevel(bool shouldUnloadPersistent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "UnloadLevel");

	Params::DungeonLevelInstance_UnloadLevel Parms{};

	Parms.shouldUnloadPersistent = shouldUnloadPersistent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonLevelInstance.UpdateWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FTransform&                connectorTransformWS                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                destConnectorTransformLS                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonLevelInstance::UpdateWorldTransform(const struct FTransform& connectorTransformWS, const struct FTransform& destConnectorTransformLS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "UpdateWorldTransform");

	Params::DungeonLevelInstance_UpdateWorldTransform Parms{};

	Parms.connectorTransformWS = std::move(connectorTransformWS);
	Parms.destConnectorTransformLS = std::move(destConnectorTransformLS);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.DungeonLevelInstance.CollidesWithAvoidVolume
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const struct FDungeonRegionVolumeInfo&  regionVolume                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevelInstance::CollidesWithAvoidVolume(const struct FDungeonRegionVolumeInfo& regionVolume) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "CollidesWithAvoidVolume");

	Params::DungeonLevelInstance_CollidesWithAvoidVolume Parms{};

	Parms.regionVolume = std::move(regionVolume);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevelInstance.CollidesWithLevelInstance
// (Final, Native, Public, Const)
// Parameters:
// class UDungeonLevelInstance*            LevelInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevelInstance::CollidesWithLevelInstance(class UDungeonLevelInstance* LevelInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "CollidesWithLevelInstance");

	Params::DungeonLevelInstance_CollidesWithLevelInstance Parms{};

	Parms.LevelInstance = LevelInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevelInstance.GetConnection
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const class FString&                    ConnectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDungeonLevelConnection*         ConnectionInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonLevelInstance::GetConnection(const class FString& ConnectionName, struct FDungeonLevelConnection* ConnectionInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "GetConnection");

	Params::DungeonLevelInstance_GetConnection Parms{};

	Parms.ConnectionName = std::move(ConnectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ConnectionInfo != nullptr)
		*ConnectionInfo = std::move(Parms.ConnectionInfo);

	return Parms.ReturnValue;
}


// Function EvolveDungeon.DungeonLevelInstance.GetWorldRegionVolumes
// (Final, Native, Public, Const)
// Parameters:
// TArray<struct FDungeonRegionVolumeInfo> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDungeonRegionVolumeInfo> UDungeonLevelInstance::GetWorldRegionVolumes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelInstance", "GetWorldRegionVolumes");

	Params::DungeonLevelInstance_GetWorldRegionVolumes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EvolveDungeon.LevelStreamingDistance.OnHidden
// (Final, Native, Private)

void ULevelStreamingDistance::OnHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelStreamingDistance", "OnHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.LevelStreamingDistance.OnLoaded
// (Final, Native, Private)

void ULevelStreamingDistance::OnLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelStreamingDistance", "OnLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EvolveDungeon.LevelStreamingDistance.OnShown
// (Final, Native, Private)

void ULevelStreamingDistance::OnShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelStreamingDistance", "OnShown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

