#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: W_InventoryUI

#include "Basic.hpp"

#include "W_InventoryUI_classes.hpp"
#include "W_InventoryUI_parameters.hpp"


namespace SDK
{

// Function W_InventoryUI.W_InventoryUI_C.AttemptToMoveDanglie
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::AttemptToMoveDanglie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "AttemptToMoveDanglie");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.AttemptToMoveItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::AttemptToMoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "AttemptToMoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.CalculateCrabBotDanglies
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::CalculateCrabBotDanglies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "CalculateCrabBotDanglies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.CalculateCrabBotHover
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::CalculateCrabBotHover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "CalculateCrabBotHover");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.CloseCrabBot
// (BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::CloseCrabBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "CloseCrabBot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.Construct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UW_InventoryUI_C::Construct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "Construct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.ContainerBindings
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UW_Container_C*                   Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ContainerBindings(class UW_Container_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ContainerBindings");

	Params::W_InventoryUI_C_ContainerBindings Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.ContainerDamaged
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ASInventoryContainer*&      Container                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ContainerDamaged(const class ASInventoryContainer*& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ContainerDamaged");

	Params::W_InventoryUI_C_ContainerDamaged Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.ContainerHoverCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Hovered                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ContainerHoverCheck(bool* Hovered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ContainerHoverCheck");

	Params::W_InventoryUI_C_ContainerHoverCheck Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Hovered != nullptr)
		*Hovered = Parms.Hovered;
}


// Function W_InventoryUI.W_InventoryUI_C.ContainerHovered
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UW_Container_C*                   Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    NewHover                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ContainerHovered(class UW_Container_C* Container, bool NewHover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ContainerHovered");

	Params::W_InventoryUI_C_ContainerHovered Parms{};

	Parms.Container = Container;
	Parms.NewHover = NewHover;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.ContainerUpdated
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWRigContainersComponent*        Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ContainerUpdated(class UFWRigContainersComponent* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ContainerUpdated");

	Params::W_InventoryUI_C_ContainerUpdated Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.DangleHoverCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Hovered                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::DangleHoverCheck(bool* Hovered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "DangleHoverCheck");

	Params::W_InventoryUI_C_DangleHoverCheck Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Hovered != nullptr)
		*Hovered = Parms.Hovered;
}


// Function W_InventoryUI.W_InventoryUI_C.DangleHovered
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    NewHover                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::DangleHovered(const class FString& Socket, bool NewHover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "DangleHovered");

	Params::W_InventoryUI_C_DangleHovered Parms{};

	Parms.Socket = std::move(Socket);
	Parms.NewHover = NewHover;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.DanglePressed
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UFWDanglyComponent*               Dangle                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::DanglePressed(const class FString& Socket, class UFWDanglyComponent* Dangle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "DanglePressed");

	Params::W_InventoryUI_C_DanglePressed Parms{};

	Parms.Socket = std::move(Socket);
	Parms.Dangle = Dangle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.DangleReleased
// (BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::DangleReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "DangleReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.Destruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UW_InventoryUI_C::Destruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "Destruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.Drop
// (Public, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::Drop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "Drop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.DropHoverCheck
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::DropHoverCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "DropHoverCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.DropHovered
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::DropHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "DropHovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.ExecuteUbergraph_W_InventoryUI
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ExecuteUbergraph_W_InventoryUI(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ExecuteUbergraph_W_InventoryUI");

	Params::W_InventoryUI_C_ExecuteUbergraph_W_InventoryUI Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.GetContainerWeight
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::GetContainerWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "GetContainerWeight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.HideItemPreviews
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::HideItemPreviews()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "HideItemPreviews");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.HoverCheck
// (Public, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::HoverCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "HoverCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.InitializeRigUI
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::InitializeRigUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "InitializeRigUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.InvalidateHoveredObjects
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::InvalidateHoveredObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "InvalidateHoveredObjects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.IsFromCrabBot?
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::IsFromCrabBot_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "IsFromCrabBot?");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.ItemHovered
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Hovered                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UW_Item_C*                        Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ItemHovered(bool Hovered, class UW_Item_C* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ItemHovered");

	Params::W_InventoryUI_C_ItemHovered Parms{};

	Parms.Hovered = Hovered;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.ItemPressed
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UW_Container_C*                   Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UW_Item_C*                        Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::ItemPressed(class UW_Container_C* Container, class UW_Item_C* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ItemPressed");

	Params::W_InventoryUI_C_ItemPressed Parms{};

	Parms.Container = Container;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.ItemReleased
// (BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::ItemReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ItemReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.MultiDanglyBindings
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UW_MultiDangleContainer_C*        MultiDangly                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::MultiDanglyBindings(class UW_MultiDangleContainer_C* MultiDangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "MultiDanglyBindings");

	Params::W_InventoryUI_C_MultiDanglyBindings Parms{};

	Parms.MultiDangly = MultiDangly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.OnKeyDown
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGeometry&                 MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// const struct FKeyEvent&                 InKeyEvent                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UW_InventoryUI_C::OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "OnKeyDown");

	Params::W_InventoryUI_C_OnKeyDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function W_InventoryUI.W_InventoryUI_C.OpenCrabBot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWRigContainersComponent*        CrabBotContainer_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UFWMultiRigDanglySlot*            CrabBotMultiDangly                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::OpenCrabBot(class UFWRigContainersComponent* CrabBotContainer_0, class UFWMultiRigDanglySlot* CrabBotMultiDangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "OpenCrabBot");

	Params::W_InventoryUI_C_OpenCrabBot Parms{};

	Parms.CrabBotContainer_0 = CrabBotContainer_0;
	Parms.CrabBotMultiDangly = CrabBotMultiDangly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.RecalculateContainerLocations
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::RecalculateContainerLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "RecalculateContainerLocations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.RecalculateItemLocation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::RecalculateItemLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "RecalculateItemLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.RefreshDangles
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    NewContainerSlot                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    OldContainerSlot                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UW_InventoryUI_C::RefreshDangles(const class FString& NewContainerSlot, const class FString& OldContainerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "RefreshDangles");

	Params::W_InventoryUI_C_RefreshDangles Parms{};

	Parms.NewContainerSlot = std::move(NewContainerSlot);
	Parms.OldContainerSlot = std::move(OldContainerSlot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.ShowItemPreviews
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::ShowItemPreviews()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "ShowItemPreviews");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.Sound_UI_SFX
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Open_                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::Sound_UI_SFX(int32 Open_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "Sound_UI_SFX");

	Params::W_InventoryUI_C_Sound_UI_SFX Parms{};

	Parms.Open_ = Open_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.Tick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const struct FGeometry&                 MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   InDeltaTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_InventoryUI_C::Tick(const struct FGeometry& MyGeometry, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "Tick");

	Params::W_InventoryUI_C_Tick Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_InventoryUI.W_InventoryUI_C.UpdateDragIcon
// (Public, BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::UpdateDragIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "UpdateDragIcon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_InventoryUI.W_InventoryUI_C.WeightInfoManager
// (BlueprintCallable, BlueprintEvent)

void UW_InventoryUI_C::WeightInfoManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_InventoryUI_C", "WeightInfoManager");

	UObject::ProcessEvent(Func, nullptr);
}

}

