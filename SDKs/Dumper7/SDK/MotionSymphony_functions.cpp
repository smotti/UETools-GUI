#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionSymphony

#include "Basic.hpp"

#include "MotionSymphony_classes.hpp"
#include "MotionSymphony_parameters.hpp"


namespace SDK
{

// Function MotionSymphony.DistanceMatching.DetectTransitions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceMatching::DetectTransitions(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "DetectTransitions");

	Params::DistanceMatching_DetectTransitions Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.GetAndConsumeTriggeredTransition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDistanceMatchTrigger                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDistanceMatchTrigger UDistanceMatching::GetAndConsumeTriggeredTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "GetAndConsumeTriggeredTransition");

	Params::DistanceMatching_GetAndConsumeTriggeredTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.DistanceMatching.GetMarkerDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDistanceMatching::GetMarkerDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "GetMarkerDistance");

	Params::DistanceMatching_GetMarkerDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.DistanceMatching.StopDistanceMatching
// (Final, Native, Public, BlueprintCallable)

void UDistanceMatching::StopDistanceMatching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "StopDistanceMatching");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceMatching::TriggerJump(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerJump");

	Params::DistanceMatching_TriggerJump Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerPivotFrom
// (Final, Native, Public, BlueprintCallable)

void UDistanceMatching::TriggerPivotFrom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerPivotFrom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerPivotTo
// (Final, Native, Public, BlueprintCallable)

void UDistanceMatching::TriggerPivotTo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerPivotTo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerPlant
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceMatching::TriggerPlant(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerPlant");

	Params::DistanceMatching_TriggerPlant Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceMatching::TriggerStart(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerStart");

	Params::DistanceMatching_TriggerStart Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceMatching::TriggerStop(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerStop");

	Params::DistanceMatching_TriggerStop Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerTurnInPlaceFrom
// (Final, Native, Public, BlueprintCallable)

void UDistanceMatching::TriggerTurnInPlaceFrom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerTurnInPlaceFrom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.DistanceMatching.TriggerTurnInPlaceTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   DesiredDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceMatching::TriggerTurnInPlaceTo(const struct FVector& DesiredDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceMatching", "TriggerTurnInPlaceTo");

	Params::DistanceMatching_TriggerTurnInPlaceTo Parms{};

	Parms.DesiredDirection = std::move(DesiredDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.ConstructMotionInputFeatureArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMotionMatchingInputData&        InputData                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMotionMatchConfig*               MotionConfig                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMMBlueprintFunctionLibrary::ConstructMotionInputFeatureArray(struct FMotionMatchingInputData& InputData, class AActor* Actor, class UMotionMatchConfig* MotionConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "ConstructMotionInputFeatureArray");

	Params::MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray Parms{};

	Parms.InputData = std::move(InputData);
	Parms.Actor = Actor;
	Parms.MotionConfig = MotionConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InputData = std::move(Parms.InputData);
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.CreateInputDataFromTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTrajectory&                     Trajectory                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMotionMatchingInputData&        InputData                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMMBlueprintFunctionLibrary::CreateInputDataFromTrajectory(struct FTrajectory& Trajectory, struct FMotionMatchingInputData& InputData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "CreateInputDataFromTrajectory");

	Params::MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.InputData = std::move(InputData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Trajectory = std::move(Parms.Trajectory);
	InputData = std::move(Parms.InputData);
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.GetInputVectorRelativeToCamera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InputVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMMBlueprintFunctionLibrary::GetInputVectorRelativeToCamera(const struct FVector& InputVector, class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "GetInputVectorRelativeToCamera");

	Params::MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera Parms{};

	Parms.InputVector = std::move(InputVector);
	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.GetVectorRelativeToCamera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const float                             InputX                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InputY                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMMBlueprintFunctionLibrary::GetVectorRelativeToCamera(const float InputX, const float InputY, class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "GetVectorRelativeToCamera");

	Params::MMBlueprintFunctionLibrary_GetVectorRelativeToCamera Parms{};

	Parms.InputX = InputX;
	Parms.InputY = InputY;
	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.InitializeTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTrajectory&                     OutTrajectory                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             TrajectoryCount                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMMBlueprintFunctionLibrary::InitializeTrajectory(struct FTrajectory& OutTrajectory, const int32 TrajectoryCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "InitializeTrajectory");

	Params::MMBlueprintFunctionLibrary_InitializeTrajectory Parms{};

	Parms.OutTrajectory = std::move(OutTrajectory);
	Parms.TrajectoryCount = TrajectoryCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutTrajectory = std::move(Parms.OutTrajectory);
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.SetTrajectoryPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTrajectory&                     OutTrajectory                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             RotationZ                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMMBlueprintFunctionLibrary::SetTrajectoryPoint(struct FTrajectory& OutTrajectory, const int32 Index_0, const struct FVector& Position, const float RotationZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "SetTrajectoryPoint");

	Params::MMBlueprintFunctionLibrary_SetTrajectoryPoint Parms{};

	Parms.OutTrajectory = std::move(OutTrajectory);
	Parms.Index_0 = Index_0;
	Parms.Position = std::move(Position);
	Parms.RotationZ = RotationZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutTrajectory = std::move(Parms.OutTrajectory);
}


// Function MotionSymphony.MMBlueprintFunctionLibrary.TransformFromUpForwardAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform&                      OutTransform                                           (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EAllAxis                          UpAxis                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EAllAxis                          ForwardAxis                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMMBlueprintFunctionLibrary::TransformFromUpForwardAxis(struct FTransform& OutTransform, const EAllAxis UpAxis, const EAllAxis ForwardAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MMBlueprintFunctionLibrary", "TransformFromUpForwardAxis");

	Params::MMBlueprintFunctionLibrary_TransformFromUpForwardAxis Parms{};

	Parms.OutTransform = std::move(OutTransform);
	Parms.UpAxis = UpAxis;
	Parms.ForwardAxis = ForwardAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutTransform = std::move(Parms.OutTransform);
}


// Function MotionSymphony.MotionCalibration.OnGenerateWeightings
// (Native, Event, Public, BlueprintEvent)

void UMotionCalibration::OnGenerateWeightings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionCalibration", "OnGenerateWeightings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.MotionTag.GetTagName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMotionTag::GetTagName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTag", "GetTagName");

	Params::MotionTag_GetTagName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.MotionTag.Received_RunPreProcessForTag
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   PoseInterval                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionTag::Received_RunPreProcessForTag(float PoseInterval) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTag", "Received_RunPreProcessForTag");

	Params::MotionTag_Received_RunPreProcessForTag Parms{};

	Parms.PoseInterval = PoseInterval;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MotionSymphony.MSFootLockerMath.AngleBetween
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMSFootLockerMath::AngleBetween(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MSFootLockerMath", "AngleBetween");

	Params::MSFootLockerMath_AngleBetween Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.MSFootLockManager.LockFoot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EMSFootLockId                     FootId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMSFootLockManager::LockFoot(const EMSFootLockId FootId, const float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MSFootLockManager", "LockFoot");

	Params::MSFootLockManager_LockFoot Parms{};

	Parms.FootId = FootId;
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.MSFootLockManager.ResetLockingState
// (Final, Native, Public, BlueprintCallable)

void UMSFootLockManager::ResetLockingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MSFootLockManager", "ResetLockingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.MSFootLockManager.UnlockFoot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EMSFootLockId                     FootId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMSFootLockManager::UnlockFoot(const EMSFootLockId FootId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MSFootLockManager", "UnlockFoot");

	Params::MSFootLockManager_UnlockFoot Parms{};

	Parms.FootId = FootId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.MSFootLockManager.IsFootLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EMSFootLockId                     FootId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMSFootLockManager::IsFootLocked(const EMSFootLockId FootId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MSFootLockManager", "IsFootLocked");

	Params::MSFootLockManager_IsFootLocked Parms{};

	Parms.FootId = FootId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.TagPoint.Received_PreProcessTag
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FPoseMotionData&           PointPose                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMotionAnimObject*                OutMotionAnim                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMotionDataAsset*                 OutMotionData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTagPoint::Received_PreProcessTag(const struct FPoseMotionData& PointPose, class UMotionAnimObject* OutMotionAnim, class UMotionDataAsset* OutMotionData, const float Time) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagPoint", "Received_PreProcessTag");

	Params::TagPoint_Received_PreProcessTag Parms{};

	Parms.PointPose = std::move(PointPose);
	Parms.OutMotionAnim = OutMotionAnim;
	Parms.OutMotionData = OutMotionData;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MotionSymphony.TagSection.Received_PreProcessPose
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FPoseMotionData&                 OutPose                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMotionAnimObject*                OutMotionAnim                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMotionDataAsset*                 OutMotionData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             StartTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             EndTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTagSection::Received_PreProcessPose(struct FPoseMotionData& OutPose, class UMotionAnimObject* OutMotionAnim, class UMotionDataAsset* OutMotionData, const float StartTime, const float EndTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagSection", "Received_PreProcessPose");

	Params::TagSection_Received_PreProcessPose Parms{};

	Parms.OutPose = std::move(OutPose);
	Parms.OutMotionAnim = OutMotionAnim;
	Parms.OutMotionData = OutMotionData;
	Parms.StartTime = StartTime;
	Parms.EndTime = EndTime;

	UObject::ProcessEvent(Func, &Parms);

	OutPose = std::move(Parms.OutPose);

	return Parms.ReturnValue;
}


// Function MotionSymphony.TagSection.Received_PreProcessTag
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UMotionAnimObject*                OutMotionAnim                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMotionDataAsset*                 OutMotionData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             StartTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             EndTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTagSection::Received_PreProcessTag(class UMotionAnimObject* OutMotionAnim, class UMotionDataAsset* OutMotionData, const float StartTime, const float EndTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagSection", "Received_PreProcessTag");

	Params::TagSection_Received_PreProcessTag Parms{};

	Parms.OutMotionAnim = OutMotionAnim;
	Parms.OutMotionData = OutMotionData;
	Parms.StartTime = StartTime;
	Parms.EndTime = EndTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MotionSymphony.TrajectoryErrorWarping.ApplyTrajectoryErrorWarping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             DeltaTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PlaybackSpeed                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryErrorWarping::ApplyTrajectoryErrorWarping(const float DeltaTime, const float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryErrorWarping", "ApplyTrajectoryErrorWarping");

	Params::TrajectoryErrorWarping_ApplyTrajectoryErrorWarping Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryErrorWarping.SetMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ETrajectoryErrorWarpMode          InWarpMode                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InWarpRate                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InMinTrajectoryLength                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinActivation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxActivation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryErrorWarping::SetMode(const ETrajectoryErrorWarpMode InWarpMode, const float InWarpRate, const float InMinTrajectoryLength, const float MinActivation, const float MaxActivation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryErrorWarping", "SetMode");

	Params::TrajectoryErrorWarping_SetMode Parms{};

	Parms.InWarpMode = InWarpMode;
	Parms.InWarpRate = InWarpRate;
	Parms.InMinTrajectoryLength = InMinTrajectoryLength;
	Parms.MinActivation = MinActivation;
	Parms.MaxActivation = MaxActivation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryErrorWarping.CalculateTrajectoryErrorWarping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             DeltaTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PlaybackSpeed                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTrajectoryErrorWarping::CalculateTrajectoryErrorWarping(const float DeltaTime, const float PlaybackSpeed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryErrorWarping", "CalculateTrajectoryErrorWarping");

	Params::TrajectoryErrorWarping_CalculateTrajectoryErrorWarping Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.TrajectoryGenerator_Base.ClearInputProfile
// (Final, Native, Public, BlueprintCallable)

void UTrajectoryGenerator_Base::ClearInputProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "ClearInputProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.DrawTrajectoryDebug
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   DrawOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::DrawTrajectoryDebug(const struct FVector& DrawOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "DrawTrajectoryDebug");

	Params::TrajectoryGenerator_Base_DrawTrajectoryDebug Parms{};

	Parms.DrawOffset = std::move(DrawOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.HasMoveInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTrajectoryGenerator_Base::HasMoveInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "HasMoveInput");

	Params::TrajectoryGenerator_Base_HasMoveInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.TrajectoryGenerator_Base.IsIdle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTrajectoryGenerator_Base::IsIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "IsIdle");

	Params::TrajectoryGenerator_Base_IsIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.TrajectoryGenerator_Base.SetCharacterSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkelMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::SetCharacterSkeletalMeshComponent(class USkeletalMeshComponent* InSkelMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "SetCharacterSkeletalMeshComponent");

	Params::TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent Parms{};

	Parms.InSkelMesh = InSkelMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.SetInputProfile
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputProfile&                   InInputProfile                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::SetInputProfile(struct FInputProfile& InInputProfile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "SetInputProfile");

	Params::TrajectoryGenerator_Base_SetInputProfile Parms{};

	Parms.InInputProfile = std::move(InInputProfile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InInputProfile = std::move(Parms.InInputProfile);
}


// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   XAxisValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YAxisValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZAxisValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::SetTrajectoryInput(float XAxisValue, float YAxisValue, float ZAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "SetTrajectoryInput");

	Params::TrajectoryGenerator_Base_SetTrajectoryInput Parms{};

	Parms.XAxisValue = XAxisValue;
	Parms.YAxisValue = YAxisValue;
	Parms.ZAxisValue = ZAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInputX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   XAxisValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::SetTrajectoryInputX(float XAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "SetTrajectoryInputX");

	Params::TrajectoryGenerator_Base_SetTrajectoryInputX Parms{};

	Parms.XAxisValue = XAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInputY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   YAxisValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::SetTrajectoryInputY(float YAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "SetTrajectoryInputY");

	Params::TrajectoryGenerator_Base_SetTrajectoryInputY Parms{};

	Parms.YAxisValue = YAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInputZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ZAxisValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator_Base::SetTrajectoryInputZ(float ZAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "SetTrajectoryInputZ");

	Params::TrajectoryGenerator_Base_SetTrajectoryInputZ Parms{};

	Parms.ZAxisValue = ZAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionSymphony.TrajectoryGenerator_Base.GetCurrentTrajectory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTrajectory                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FTrajectory UTrajectoryGenerator_Base::GetCurrentTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator_Base", "GetCurrentTrajectory");

	Params::TrajectoryGenerator_Base_GetCurrentTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionSymphony.TrajectoryGenerator.SetStrafeDirectionFromCamera
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 Camera                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrajectoryGenerator::SetStrafeDirectionFromCamera(class UCameraComponent* Camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrajectoryGenerator", "SetStrafeDirectionFromCamera");

	Params::TrajectoryGenerator_SetStrafeDirectionFromCamera Parms{};

	Parms.Camera = Camera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

