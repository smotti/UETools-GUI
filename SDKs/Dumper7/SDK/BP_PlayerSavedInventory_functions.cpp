#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerSavedInventory

#include "Basic.hpp"

#include "BP_PlayerSavedInventory_classes.hpp"
#include "BP_PlayerSavedInventory_parameters.hpp"


namespace SDK
{

// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedContainer&           SavedContainer                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::AddContainer(const struct FSavedContainer& SavedContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddContainer");

	Params::BP_PlayerSavedInventory_C_AddContainer Parms{};

	Parms.SavedContainer = std::move(SavedContainer);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedDangly&              Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::AddDangly(const struct FSavedDangly& Dangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddDangly");

	Params::BP_PlayerSavedInventory_C_AddDangly Parms{};

	Parms.Dangly = std::move(Dangly);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddFrame
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedFrame&               Frame                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::AddFrame(const struct FSavedFrame& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddFrame");

	Params::BP_PlayerSavedInventory_C_AddFrame Parms{};

	Parms.Frame = std::move(Frame);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::AddItem(const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddItem");

	Params::BP_PlayerSavedInventory_C_AddItem Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FSavedItem>&        NewItems                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_PlayerSavedInventory_C::AddItems(const TArray<struct FSavedItem>& NewItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddItems");

	Params::BP_PlayerSavedInventory_C_AddItems Parms{};

	Parms.NewItems = std::move(NewItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddRig
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       NewRig                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::AddRig(const struct FDataTableRowHandle& NewRig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddRig");

	Params::BP_PlayerSavedInventory_C_AddRig Parms{};

	Parms.NewRig = std::move(NewRig);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddTestData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSavedItem>&              Items_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedWeapon>&            Weapons_0                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedDangly>&            Danglies_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_PlayerSavedInventory_C::AddTestData(TArray<struct FSavedItem>& Items_0, TArray<struct FSavedWeapon>& Weapons_0, TArray<struct FSavedDangly>& Danglies_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddTestData");

	Params::BP_PlayerSavedInventory_C_AddTestData Parms{};

	Parms.Items_0 = std::move(Items_0);
	Parms.Weapons_0 = std::move(Weapons_0);
	Parms.Danglies_0 = std::move(Danglies_0);

	UObject::ProcessEvent(Func, &Parms);

	Items_0 = std::move(Parms.Items_0);
	Weapons_0 = std::move(Parms.Weapons_0);
	Danglies_0 = std::move(Parms.Danglies_0);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.AddWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::AddWeapon(const struct FSavedWeapon& Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "AddWeapon");

	Params::BP_PlayerSavedInventory_C_AddWeapon Parms{};

	Parms.Weapon = std::move(Weapon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.DeconflictLoadout
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FDataTableRowHandle>&     Containers_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     Frames_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     Weapons_0                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     WeaponParts                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedItem>&              Items_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedDangly>&            Danglies_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_PlayerSavedInventory_C::DeconflictLoadout(TArray<struct FDataTableRowHandle>& Containers_0, TArray<struct FDataTableRowHandle>& Frames_0, TArray<struct FDataTableRowHandle>& Weapons_0, TArray<struct FDataTableRowHandle>& WeaponParts, TArray<struct FSavedItem>& Items_0, TArray<struct FSavedDangly>& Danglies_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "DeconflictLoadout");

	Params::BP_PlayerSavedInventory_C_DeconflictLoadout Parms{};

	Parms.Containers_0 = std::move(Containers_0);
	Parms.Frames_0 = std::move(Frames_0);
	Parms.Weapons_0 = std::move(Weapons_0);
	Parms.WeaponParts = std::move(WeaponParts);
	Parms.Items_0 = std::move(Items_0);
	Parms.Danglies_0 = std::move(Danglies_0);

	UObject::ProcessEvent(Func, &Parms);

	Containers_0 = std::move(Parms.Containers_0);
	Frames_0 = std::move(Parms.Frames_0);
	Weapons_0 = std::move(Parms.Weapons_0);
	WeaponParts = std::move(Parms.WeaponParts);
	Items_0 = std::move(Parms.Items_0);
	Danglies_0 = std::move(Parms.Danglies_0);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.GetContainers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedContainer>*         Containers_0                                           (Parm, OutParm)

void UBP_PlayerSavedInventory_C::GetContainers(TArray<struct FSavedContainer>* Containers_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "GetContainers");

	Params::BP_PlayerSavedInventory_C_GetContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers_0 != nullptr)
		*Containers_0 = std::move(Parms.Containers_0);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.GetDanglies
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedDangly>*            Danglies_0                                             (Parm, OutParm)

void UBP_PlayerSavedInventory_C::GetDanglies(TArray<struct FSavedDangly>* Danglies_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "GetDanglies");

	Params::BP_PlayerSavedInventory_C_GetDanglies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Danglies_0 != nullptr)
		*Danglies_0 = std::move(Parms.Danglies_0);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.GetFrames
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedFrame>*             Frames_0                                               (Parm, OutParm)

void UBP_PlayerSavedInventory_C::GetFrames(TArray<struct FSavedFrame>* Frames_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "GetFrames");

	Params::BP_PlayerSavedInventory_C_GetFrames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Frames_0 != nullptr)
		*Frames_0 = std::move(Parms.Frames_0);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.GetWeaponMods
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>&                    Mods                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedItem>*              Saved_Parts_Removed                                    (Parm, OutParm)

void UBP_PlayerSavedInventory_C::GetWeaponMods(TArray<class FName>& Mods, TArray<struct FSavedItem>* Saved_Parts_Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "GetWeaponMods");

	Params::BP_PlayerSavedInventory_C_GetWeaponMods Parms{};

	Parms.Mods = std::move(Mods);

	UObject::ProcessEvent(Func, &Parms);

	Mods = std::move(Parms.Mods);

	if (Saved_Parts_Removed != nullptr)
		*Saved_Parts_Removed = std::move(Parms.Saved_Parts_Removed);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.GetWeapons
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedWeapon>*            Weapons_0                                              (Parm, OutParm)

void UBP_PlayerSavedInventory_C::GetWeapons(TArray<struct FSavedWeapon>* Weapons_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "GetWeapons");

	Params::BP_PlayerSavedInventory_C_GetWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weapons_0 != nullptr)
		*Weapons_0 = std::move(Parms.Weapons_0);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.PatchCraftingInUse
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerSavedInventory_C::PatchCraftingInUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "PatchCraftingInUse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.PatchDisabledWeapons
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerSavedInventory_C::PatchDisabledWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "PatchDisabledWeapons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.PatchSave
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerSavedInventory_C::PatchSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "PatchSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.Remove Stash Item
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerSavedInventory_C::Remove_Stash_Item(const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "Remove Stash Item");

	Params::BP_PlayerSavedInventory_C_Remove_Stash_Item Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedContainer&           Container                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::RemoveContainer(const struct FSavedContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveContainer");

	Params::BP_PlayerSavedInventory_C_RemoveContainer Parms{};

	Parms.Container = std::move(Container);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedDangly&              Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerSavedInventory_C::RemoveDangly(const struct FSavedDangly& Dangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveDangly");

	Params::BP_PlayerSavedInventory_C_RemoveDangly Parms{};

	Parms.Dangly = std::move(Dangly);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveFrame
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedFrame&               Frame                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::RemoveFrame(const struct FSavedFrame& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveFrame");

	Params::BP_PlayerSavedInventory_C_RemoveFrame Parms{};

	Parms.Frame = std::move(Frame);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FBackpackRigDefaults&      CustomBackpack                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedContainer>*         Containers_Used                                        (Parm, OutParm)
// TArray<struct FSavedFrame>*             Frames_Used                                            (Parm, OutParm)

void UBP_PlayerSavedInventory_C::RemoveItems(const struct FBackpackRigDefaults& CustomBackpack, TArray<struct FSavedContainer>* Containers_Used, TArray<struct FSavedFrame>* Frames_Used)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveItems");

	Params::BP_PlayerSavedInventory_C_RemoveItems Parms{};

	Parms.CustomBackpack = std::move(CustomBackpack);

	UObject::ProcessEvent(Func, &Parms);

	if (Containers_Used != nullptr)
		*Containers_Used = std::move(Parms.Containers_Used);

	if (Frames_Used != nullptr)
		*Frames_Used = std::move(Parms.Frames_Used);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_PlayerSavedInventory_C::RemoveWeapon(const struct FSavedWeapon& Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveWeapon");

	Params::BP_PlayerSavedInventory_C_RemoveWeapon Parms{};

	Parms.Weapon = std::move(Weapon);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveWeaponMods
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>&                    Mods                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSavedItem>*              Saved_Parts_Removed                                    (Parm, OutParm)

bool UBP_PlayerSavedInventory_C::RemoveWeaponMods(TArray<class FName>& Mods, TArray<struct FSavedItem>* Saved_Parts_Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveWeaponMods");

	Params::BP_PlayerSavedInventory_C_RemoveWeaponMods Parms{};

	Parms.Mods = std::move(Mods);

	UObject::ProcessEvent(Func, &Parms);

	Mods = std::move(Parms.Mods);

	if (Saved_Parts_Removed != nullptr)
		*Saved_Parts_Removed = std::move(Parms.Saved_Parts_Removed);

	return Parms.ReturnValue;
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RemoveWeapons
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              PrimaryWeapon                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FSavedWeapon&              SecondaryWeapon                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UBP_PlayerSavedInventory_C::RemoveWeapons(const struct FSavedWeapon& PrimaryWeapon, const struct FSavedWeapon& SecondaryWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RemoveWeapons");

	Params::BP_PlayerSavedInventory_C_RemoveWeapons Parms{};

	Parms.PrimaryWeapon = std::move(PrimaryWeapon);
	Parms.SecondaryWeapon = std::move(SecondaryWeapon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.RestoreWeapons
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              PrimaryWeapon                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// const struct FSavedWeapon&              SecondaryWeapon                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBP_PlayerSavedInventory_C::RestoreWeapons(const struct FSavedWeapon& PrimaryWeapon, const struct FSavedWeapon& SecondaryWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "RestoreWeapons");

	Params::BP_PlayerSavedInventory_C_RestoreWeapons Parms{};

	Parms.PrimaryWeapon = std::move(PrimaryWeapon);
	Parms.SecondaryWeapon = std::move(SecondaryWeapon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerSavedInventory.BP_PlayerSavedInventory_C.SaveInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerSavedInventory_C::SaveInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerSavedInventory_C", "SaveInventory");

	UObject::ProcessEvent(Func, nullptr);
}

}

