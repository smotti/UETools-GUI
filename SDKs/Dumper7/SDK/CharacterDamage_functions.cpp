#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterDamage

#include "Basic.hpp"

#include "CharacterDamage_classes.hpp"
#include "CharacterDamage_parameters.hpp"


namespace SDK
{

// Function CharacterDamage.CharacterDamage_C.Add Gore
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// double                                  Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class UDamageType*                DamageType                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UCharacterDamage_C::Add_Gore(const struct FHitResult& HitResult, double Damage, const class UDamageType* DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "Add Gore");

	Params::CharacterDamage_C_Add_Gore Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterDamage.CharacterDamage_C.Damage Joint
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      Joint_Name                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Impact_Normal                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Impact_Location                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Joint_Damage                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Dislocated                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCharacterDamage_C::Damage_Joint(const class FName& Joint_Name, const struct FVector& Impact_Normal, const struct FVector& Impact_Location, double Joint_Damage, bool* Dislocated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "Damage Joint");

	Params::CharacterDamage_C_Damage_Joint Parms{};

	Parms.Joint_Name = Joint_Name;
	Parms.Impact_Normal = std::move(Impact_Normal);
	Parms.Impact_Location = std::move(Impact_Location);
	Parms.Joint_Damage = Joint_Damage;

	UObject::ProcessEvent(Func, &Parms);

	if (Dislocated != nullptr)
		*Dislocated = Parms.Dislocated;
}


// Function CharacterDamage.CharacterDamage_C.DetermineRadiusAndDamage
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit_Result                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// double                                  Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class UDamageType*                DamageType                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double*                                 Radius                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 JointDamage                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   is_Radial_Damage                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      Out_Hit_Result                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UCharacterDamage_C::DetermineRadiusAndDamage(const struct FHitResult& Hit_Result, double Damage, const class UDamageType* DamageType, double* Radius, double* JointDamage, bool* is_Radial_Damage, struct FHitResult* Out_Hit_Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "DetermineRadiusAndDamage");

	Params::CharacterDamage_C_DetermineRadiusAndDamage Parms{};

	Parms.Hit_Result = std::move(Hit_Result);
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;

	UObject::ProcessEvent(Func, &Parms);

	if (Radius != nullptr)
		*Radius = Parms.Radius;

	if (JointDamage != nullptr)
		*JointDamage = Parms.JointDamage;

	if (is_Radial_Damage != nullptr)
		*is_Radial_Damage = Parms.is_Radial_Damage;

	if (Out_Hit_Result != nullptr)
		*Out_Hit_Result = std::move(Parms.Out_Hit_Result);
}


// Function CharacterDamage.CharacterDamage_C.DisconnectPart
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UCharacterDamage_C::DisconnectPart(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "DisconnectPart");

	Params::CharacterDamage_C_DisconnectPart Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterDamage.CharacterDamage_C.ExecuteUbergraph_CharacterDamage
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCharacterDamage_C::ExecuteUbergraph_CharacterDamage(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "ExecuteUbergraph_CharacterDamage");

	Params::CharacterDamage_C_ExecuteUbergraph_CharacterDamage Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterDamage.CharacterDamage_C.GetMaterialSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    TypeCreate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UCharacterDamage_C::GetMaterialSlots(const class FString& TypeCreate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "GetMaterialSlots");

	Params::CharacterDamage_C_GetMaterialSlots Parms{};

	Parms.TypeCreate = std::move(TypeCreate);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterDamage.CharacterDamage_C.Is Colliding with Dynamic Material At Component
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit_Result                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UMaterialInstanceDynamic*         Dynamic_Material                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class USkeletalMeshComponent*           Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   is_Colliding                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UCharacterDamage_C::Is_Colliding_with_Dynamic_Material_At_Component(const struct FHitResult& Hit_Result, class UMaterialInstanceDynamic* Dynamic_Material, class USkeletalMeshComponent* Component, bool* is_Colliding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "Is Colliding with Dynamic Material At Component");

	Params::CharacterDamage_C_Is_Colliding_with_Dynamic_Material_At_Component Parms{};

	Parms.Hit_Result = std::move(Hit_Result);
	Parms.Dynamic_Material = Dynamic_Material;
	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);

	if (is_Colliding != nullptr)
		*is_Colliding = Parms.is_Colliding;

	return Parms.ReturnValue;
}


// Function CharacterDamage.CharacterDamage_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UCharacterDamage_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterDamage.CharacterDamage_C.SoftTissueCast
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Part                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UCharacterDamage_C::SoftTissueCast(class AActor* Actor, const class FString& Part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "SoftTissueCast");

	Params::CharacterDamage_C_SoftTissueCast Parms{};

	Parms.Actor = Actor;
	Parms.Part = std::move(Part);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterDamage.CharacterDamage_C.Spawn Chunk
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Joint_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Impact_Normal                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Impact_Point                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCharacterDamage_C::Spawn_Chunk(class FName Joint_Name, const struct FVector& Impact_Normal, const struct FVector& Impact_Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "Spawn Chunk");

	Params::CharacterDamage_C_Spawn_Chunk Parms{};

	Parms.Joint_Name = Joint_Name;
	Parms.Impact_Normal = std::move(Impact_Normal);
	Parms.Impact_Point = std::move(Impact_Point);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterDamage.CharacterDamage_C.Spawn Inner Layers
// (Public, BlueprintCallable, BlueprintEvent)

void UCharacterDamage_C::Spawn_Inner_Layers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDamage_C", "Spawn Inner Layers");

	UObject::ProcessEvent(Func, nullptr);
}

}

