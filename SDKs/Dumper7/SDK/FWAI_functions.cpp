#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FWAI

#include "Basic.hpp"

#include "FWAI_classes.hpp"
#include "FWAI_parameters.hpp"


namespace SDK
{

// Function FWAI.AIGlobalSubsystem.GetProjectileObjectChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UAIGlobalSubsystem::GetProjectileObjectChannel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIGlobalSubsystem", "GetProjectileObjectChannel");

	Params::AIGlobalSubsystem_GetProjectileObjectChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function FWAI.AIGlobalSubsystem.GetProjectileTraceChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UAIGlobalSubsystem::GetProjectileTraceChannel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIGlobalSubsystem", "GetProjectileTraceChannel");

	Params::AIGlobalSubsystem_GetProjectileTraceChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function FWAI.CoverMarkupActor.ClearAdjacency
// (Final, Native, Public, BlueprintCallable)

void ACoverMarkupActor::ClearAdjacency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverMarkupActor", "ClearAdjacency");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverMarkupActor.RebuildAdjacency
// (Final, Native, Public, BlueprintCallable)

void ACoverMarkupActor::RebuildAdjacency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverMarkupActor", "RebuildAdjacency");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverMarkupActor.RebuildLocations
// (Final, Native, Public, BlueprintCallable)

void ACoverMarkupActor::RebuildLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverMarkupActor", "RebuildLocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverSubsystem.EvaluateCover
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCoverDescription*               Description                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ForwardVector                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSubsystem::EvaluateCover(struct FCoverDescription* Description, const struct FVector& Location, const struct FVector& ForwardVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSubsystem", "EvaluateCover");

	Params::CoverSubsystem_EvaluateCover Parms{};

	Parms.Location = std::move(Location);
	Parms.ForwardVector = std::move(ForwardVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Description != nullptr)
		*Description = std::move(Parms.Description);
}


// Function FWAI.CoverSubsystem.EvaluateTraversal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTraversalDescription*           Description                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ForwardVector                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPassData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSubsystem::EvaluateTraversal(struct FTraversalDescription* Description, const struct FVector& Location, const struct FVector& ForwardVector, bool bPassData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSubsystem", "EvaluateTraversal");

	Params::CoverSubsystem_EvaluateTraversal Parms{};

	Parms.Location = std::move(Location);
	Parms.ForwardVector = std::move(ForwardVector);
	Parms.bPassData = bPassData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Description != nullptr)
		*Description = std::move(Parms.Description);
}


// Function FWAI.CoverSubsystem.QueryAllCover
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TScriptInterface<class ICoverLocation>>*Locations                                              (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ICoverAware>     ForWhom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSubsystem::QueryAllCover(TArray<TScriptInterface<class ICoverLocation>>* Locations, TScriptInterface<class ICoverAware> ForWhom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSubsystem", "QueryAllCover");

	Params::CoverSubsystem_QueryAllCover Parms{};

	Parms.ForWhom = ForWhom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);
}


// Function FWAI.CoverSubsystem.QueryCover
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<TScriptInterface<class ICoverLocation>>*Locations                                              (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class ICoverAware>     ForWhom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSubsystem::QueryCover(TArray<TScriptInterface<class ICoverLocation>>* Locations, const struct FVector& Location, TScriptInterface<class ICoverAware> ForWhom, float MaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSubsystem", "QueryCover");

	Params::CoverSubsystem_QueryCover Parms{};

	Parms.Location = std::move(Location);
	Parms.ForWhom = ForWhom;
	Parms.MaxDistance = MaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);
}


// Function FWAI.FWAITraversalMarkup.RebuildLocations
// (Final, Exec, Native, Protected)

void AFWAITraversalMarkup::RebuildLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FWAITraversalMarkup", "RebuildLocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverAware.OnArriveAtCover
// (Native, Public)
// Parameters:
// TScriptInterface<class ICoverLocation>  Cover                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICoverAware::OnArriveAtCover(TScriptInterface<class ICoverLocation> Cover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CoverAware", "OnArriveAtCover");

	Params::CoverAware_OnArriveAtCover Parms{};

	Parms.Cover = Cover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverAware.OnCancelMoveToCover
// (Native, Public)

void ICoverAware::OnCancelMoveToCover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CoverAware", "OnCancelMoveToCover");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverAware.OnDepartCover
// (Native, Public)
// Parameters:
// bool                                    bRemainInCover                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICoverAware::OnDepartCover(bool bRemainInCover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CoverAware", "OnDepartCover");

	Params::CoverAware_OnDepartCover Parms{};

	Parms.bRemainInCover = bRemainInCover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverAware.OnMoveToCover
// (Native, Public)
// Parameters:
// TScriptInterface<class ICoverLocation>  Cover                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICoverAware::OnMoveToCover(TScriptInterface<class ICoverLocation> Cover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CoverAware", "OnMoveToCover");

	Params::CoverAware_OnMoveToCover Parms{};

	Parms.Cover = Cover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function FWAI.CoverAware.GetCover
// (Native, Public, Const)
// Parameters:
// TScriptInterface<class ICoverLocation>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class ICoverLocation> ICoverAware::GetCover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CoverAware", "GetCover");

	Params::CoverAware_GetCover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function FWAI.CoverAwareBPL.FromCoverAwareActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECoverAwareBPLResult*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class ICoverAware>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class ICoverAware> UCoverAwareBPL::FromCoverAwareActor(class AActor* Actor, ECoverAwareBPLResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoverAwareBPL", "FromCoverAwareActor");

	Params::CoverAwareBPL_FromCoverAwareActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}

}

