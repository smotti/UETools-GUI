#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPC_PlayerSaveGames

#include "Basic.hpp"

#include "BPC_PlayerSaveGames_classes.hpp"
#include "BPC_PlayerSaveGames_parameters.hpp"


namespace SDK
{

// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddCraftingItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CraftingGroup                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              CraftingRecipy                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool*                                   StartCrafting                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddCraftingItem(const struct FGameplayTag& CraftingGroup, const struct FGameplayTag& CraftingRecipy, bool* StartCrafting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddCraftingItem");

	Params::BPC_PlayerSaveGames_C_AddCraftingItem Parms{};

	Parms.CraftingGroup = std::move(CraftingGroup);
	Parms.CraftingRecipy = std::move(CraftingRecipy);

	UObject::ProcessEvent(Func, &Parms);

	if (StartCrafting != nullptr)
		*StartCrafting = Parms.StartCrafting;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                NewItem                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// int32                                   Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddItem(const struct FSavedItem& NewItem, int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddItem");

	Params::BPC_PlayerSaveGames_C_AddItem Parms{};

	Parms.NewItem = std::move(NewItem);
	Parms.Slot = Slot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddItemFromTag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddItemFromTag(const struct FGameplayTag& Tag, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddItemFromTag");

	Params::BPC_PlayerSaveGames_C_AddItemFromTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddQuestReward
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       RowHandle                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ItemContext                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddQuestReward(const struct FDataTableRowHandle& RowHandle, int32 Count, const struct FGameplayTag& ItemContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddQuestReward");

	Params::BPC_PlayerSaveGames_C_AddQuestReward Parms{};

	Parms.RowHandle = std::move(RowHandle);
	Parms.Count = Count;
	Parms.ItemContext = std::move(ItemContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashBuddy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedBuddy&               Buddy                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddStashBuddy(const struct FSavedBuddy& Buddy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashBuddy");

	Params::BPC_PlayerSaveGames_C_AddStashBuddy Parms{};

	Parms.Buddy = std::move(Buddy);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedContainer&           Container                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddStashContainer(const struct FSavedContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashContainer");

	Params::BPC_PlayerSaveGames_C_AddStashContainer Parms{};

	Parms.Container = std::move(Container);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashCurrency
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FCurrencyDetails>&        Currencies                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::AddStashCurrency(TArray<struct FCurrencyDetails>& Currencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashCurrency");

	Params::BPC_PlayerSaveGames_C_AddStashCurrency Parms{};

	Parms.Currencies = std::move(Currencies);

	UObject::ProcessEvent(Func, &Parms);

	Currencies = std::move(Parms.Currencies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedDangly&              Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool*                                   ConvertedToWeapon                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName*                            Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddStashDangly(const struct FSavedDangly& Dangly, bool* ConvertedToWeapon, class FName* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashDangly");

	Params::BPC_PlayerSaveGames_C_AddStashDangly Parms{};

	Parms.Dangly = std::move(Dangly);

	UObject::ProcessEvent(Func, &Parms);

	if (ConvertedToWeapon != nullptr)
		*ConvertedToWeapon = Parms.ConvertedToWeapon;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashFrame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedFrame&               Frame                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddStashFrame(const struct FSavedFrame& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashFrame");

	Params::BPC_PlayerSaveGames_C_AddStashFrame Parms{};

	Parms.Frame = std::move(Frame);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddStashItem(const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashItem");

	Params::BPC_PlayerSaveGames_C_AddStashItem Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FSavedItem>&        NewItems                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::AddStashItems(const TArray<struct FSavedItem>& NewItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashItems");

	Params::BPC_PlayerSaveGames_C_AddStashItems Parms{};

	Parms.NewItems = std::move(NewItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashRig
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       NewRig                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddStashRig(const struct FDataTableRowHandle& NewRig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashRig");

	Params::BPC_PlayerSaveGames_C_AddStashRig Parms{};

	Parms.NewRig = std::move(NewRig);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashTestData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSavedItem>&              Items                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedWeapon>&            Weapons                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedDangly>&            Danglies                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FCurrencyDetails>&        Currencies                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::AddStashTestData(TArray<struct FSavedItem>& Items, TArray<struct FSavedWeapon>& Weapons, TArray<struct FSavedDangly>& Danglies, TArray<struct FCurrencyDetails>& Currencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashTestData");

	Params::BPC_PlayerSaveGames_C_AddStashTestData Parms{};

	Parms.Items = std::move(Items);
	Parms.Weapons = std::move(Weapons);
	Parms.Danglies = std::move(Danglies);
	Parms.Currencies = std::move(Currencies);

	UObject::ProcessEvent(Func, &Parms);

	Items = std::move(Parms.Items);
	Weapons = std::move(Parms.Weapons);
	Danglies = std::move(Parms.Danglies);
	Currencies = std::move(Parms.Currencies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddStashWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddStashWeapon(const struct FSavedWeapon& Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddStashWeapon");

	Params::BPC_PlayerSaveGames_C_AddStashWeapon Parms{};

	Parms.Weapon = std::move(Weapon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddToVendorRebuy
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              ItemTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddToVendorRebuy(const struct FGameplayTag& ItemTag, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddToVendorRebuy");

	Params::BPC_PlayerSaveGames_C_AddToVendorRebuy Parms{};

	Parms.ItemTag = std::move(ItemTag);
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddVaultCurrency
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCurrencyDetails&          NewCurrency                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UBPC_PlayerSaveGames_C::AddVaultCurrency(const struct FCurrencyDetails& NewCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddVaultCurrency");

	Params::BPC_PlayerSaveGames_C_AddVaultCurrency Parms{};

	Parms.NewCurrency = std::move(NewCurrency);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.AddVaultItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::AddVaultItem(const struct FGameplayTag& Item, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "AddVaultItem");

	Params::BPC_PlayerSaveGames_C_AddVaultItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Cancelled_9B09E0E24B970ABCFA3C3BBF7E766428
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPopupWidget*                   NewPopUp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Cancelled_9B09E0E24B970ABCFA3C3BBF7E766428(class UFWPopupWidget* NewPopUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Cancelled_9B09E0E24B970ABCFA3C3BBF7E766428");

	Params::BPC_PlayerSaveGames_C_Cancelled_9B09E0E24B970ABCFA3C3BBF7E766428 Parms{};

	Parms.NewPopUp = NewPopUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Cheat Cash
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int64                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Cheat_Cash(int64 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Cheat Cash");

	Params::BPC_PlayerSaveGames_C_Cheat_Cash Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.CheatGachas
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::CheatGachas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "CheatGachas");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.CheatItems
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::CheatItems(int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "CheatItems");

	Params::BPC_PlayerSaveGames_C_CheatItems Parms{};

	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ClearStash
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ClearStash(class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ClearStash");

	Params::BPC_PlayerSaveGames_C_ClearStash Parms{};

	Parms.Subsystem = Subsystem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ClearTombStoneSave
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::ClearTombStoneSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ClearTombStoneSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ClearTombStoneTimer
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::ClearTombStoneTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ClearTombStoneTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ClearTombStoneTrigger
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FDateTime&                 ExpectedOccurrence                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FTimespan&                 PastDue                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int64                                   OccurrenceCount                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ClearTombStoneTrigger(class UFWPersistenceSubsystem* Subsystem, const struct FDateTime& ExpectedOccurrence, const struct FTimespan& PastDue, int64 OccurrenceCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ClearTombStoneTrigger");

	Params::BPC_PlayerSaveGames_C_ClearTombStoneTrigger Parms{};

	Parms.Subsystem = Subsystem;
	Parms.ExpectedOccurrence = std::move(ExpectedOccurrence);
	Parms.PastDue = std::move(PastDue);
	Parms.OccurrenceCount = OccurrenceCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.CollectCraftingItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CraftingGroup                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool*                                   Removed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::CollectCraftingItem(const struct FGameplayTag& CraftingGroup, bool* Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "CollectCraftingItem");

	Params::BPC_PlayerSaveGames_C_CollectCraftingItem Parms{};

	Parms.CraftingGroup = std::move(CraftingGroup);

	UObject::ProcessEvent(Func, &Parms);

	if (Removed != nullptr)
		*Removed = Parms.Removed;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Confirmed_9B09E0E24B970ABCFA3C3BBF7E766428
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPopupWidget*                   NewPopUp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Confirmed_9B09E0E24B970ABCFA3C3BBF7E766428(class UFWPopupWidget* NewPopUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Confirmed_9B09E0E24B970ABCFA3C3BBF7E766428");

	Params::BPC_PlayerSaveGames_C_Confirmed_9B09E0E24B970ABCFA3C3BBF7E766428 Parms{};

	Parms.NewPopUp = NewPopUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ConvertDisabledWeaponRow
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             DisabledWeaponRow                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName*                            WeaponRow                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ConvertDisabledWeaponRow(class FName DisabledWeaponRow, class FName* WeaponRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ConvertDisabledWeaponRow");

	Params::BPC_PlayerSaveGames_C_ConvertDisabledWeaponRow Parms{};

	Parms.DisabledWeaponRow = DisabledWeaponRow;

	UObject::ProcessEvent(Func, &Parms);

	if (WeaponRow != nullptr)
		*WeaponRow = Parms.WeaponRow;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ConvertStashedWater
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::ConvertStashedWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ConvertStashedWater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ConvertWater
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSavedDangly>&            WaterDanglies                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::ConvertWater(TArray<struct FSavedDangly>& WaterDanglies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ConvertWater");

	Params::BPC_PlayerSaveGames_C_ConvertWater Parms{};

	Parms.WaterDanglies = std::move(WaterDanglies);

	UObject::ProcessEvent(Func, &Parms);

	WaterDanglies = std::move(Parms.WaterDanglies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Created_9B09E0E24B970ABCFA3C3BBF7E766428
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPopupWidget*                   NewPopUp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Created_9B09E0E24B970ABCFA3C3BBF7E766428(class UFWPopupWidget* NewPopUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Created_9B09E0E24B970ABCFA3C3BBF7E766428");

	Params::BPC_PlayerSaveGames_C_Created_9B09E0E24B970ABCFA3C3BBF7E766428 Parms{};

	Parms.NewPopUp = NewPopUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.CreateInitialSave
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::CreateInitialSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "CreateInitialSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.DeconflictLoadout
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       Currency                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// int32                                   Cost                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FDataTableRowHandle>&     Containers                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     Frames                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     Weapons                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     WeaponParts                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedItem>&              Items                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedDangly>&            Danglies                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::DeconflictLoadout(const struct FDataTableRowHandle& Currency, int32 Cost, TArray<struct FDataTableRowHandle>& Containers, TArray<struct FDataTableRowHandle>& Frames, TArray<struct FDataTableRowHandle>& Weapons, TArray<struct FDataTableRowHandle>& WeaponParts, TArray<struct FSavedItem>& Items, TArray<struct FSavedDangly>& Danglies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "DeconflictLoadout");

	Params::BPC_PlayerSaveGames_C_DeconflictLoadout Parms{};

	Parms.Currency = std::move(Currency);
	Parms.Cost = Cost;
	Parms.Containers = std::move(Containers);
	Parms.Frames = std::move(Frames);
	Parms.Weapons = std::move(Weapons);
	Parms.WeaponParts = std::move(WeaponParts);
	Parms.Items = std::move(Items);
	Parms.Danglies = std::move(Danglies);

	UObject::ProcessEvent(Func, &Parms);

	Containers = std::move(Parms.Containers);
	Frames = std::move(Parms.Frames);
	Weapons = std::move(Parms.Weapons);
	WeaponParts = std::move(Parms.WeaponParts);
	Items = std::move(Parms.Items);
	Danglies = std::move(Parms.Danglies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.DeleteList
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    ListName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::DeleteList(const class FString& ListName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "DeleteList");

	Params::BPC_PlayerSaveGames_C_DeleteList Parms{};

	Parms.ListName = std::move(ListName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.DeleteScavMuleSave
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::DeleteScavMuleSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "DeleteScavMuleSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.DetermineContextTag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FDataTableRowHandle&       RowHandle                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FGameplayTag*                    Tag                                                    (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::DetermineContextTag(const struct FDataTableRowHandle& RowHandle, struct FGameplayTag* Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "DetermineContextTag");

	Params::BPC_PlayerSaveGames_C_DetermineContextTag Parms{};

	Parms.RowHandle = std::move(RowHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Tag != nullptr)
		*Tag = std::move(Parms.Tag);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.DisplayHostLeaveWarning
// (BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::DisplayHostLeaveWarning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "DisplayHostLeaveWarning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ExecuteUbergraph_BPC_PlayerSaveGames
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ExecuteUbergraph_BPC_PlayerSaveGames(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ExecuteUbergraph_BPC_PlayerSaveGames");

	Params::BPC_PlayerSaveGames_C_ExecuteUbergraph_BPC_PlayerSaveGames Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ExtractLoot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    TunnelsCheckpointSave_                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Tunnels_Extract                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FDataTableRowHandle>*     Items                                                  (Parm, OutParm)
// TArray<struct FDataTableRowHandle>*     Danglies                                               (Parm, OutParm)

void UBPC_PlayerSaveGames_C::ExtractLoot(bool TunnelsCheckpointSave_, bool Tunnels_Extract, TArray<struct FDataTableRowHandle>* Items, TArray<struct FDataTableRowHandle>* Danglies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ExtractLoot");

	Params::BPC_PlayerSaveGames_C_ExtractLoot Parms{};

	Parms.TunnelsCheckpointSave_ = TunnelsCheckpointSave_;
	Parms.Tunnels_Extract = Tunnels_Extract;

	UObject::ProcessEvent(Func, &Parms);

	if (Items != nullptr)
		*Items = std::move(Parms.Items);

	if (Danglies != nullptr)
		*Danglies = std::move(Parms.Danglies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Get Loadout Save Name
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString*                          LoadoutSaveName                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Get_Loadout_Save_Name(class FString* LoadoutSaveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Get Loadout Save Name");

	Params::BPC_PlayerSaveGames_C_Get_Loadout_Save_Name Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LoadoutSaveName != nullptr)
		*LoadoutSaveName = std::move(Parms.LoadoutSaveName);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Get Rig Parts Used
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FBackpackRigDefaults&            Backpack_Rig_Defaults                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FSavedContainer>*         Containers                                             (Parm, OutParm)
// TArray<struct FSavedFrame>*             Frames                                                 (Parm, OutParm)

void UBPC_PlayerSaveGames_C::Get_Rig_Parts_Used(struct FBackpackRigDefaults& Backpack_Rig_Defaults, TArray<struct FSavedContainer>* Containers, TArray<struct FSavedFrame>* Frames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Get Rig Parts Used");

	Params::BPC_PlayerSaveGames_C_Get_Rig_Parts_Used Parms{};

	Parms.Backpack_Rig_Defaults = std::move(Backpack_Rig_Defaults);

	UObject::ProcessEvent(Func, &Parms);

	Backpack_Rig_Defaults = std::move(Parms.Backpack_Rig_Defaults);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);

	if (Frames != nullptr)
		*Frames = std::move(Parms.Frames);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetAmmoCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              AmmoType                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TMap<struct FGameplayTag, int32>*       AmmoCounts                                             (Parm, OutParm)
// TArray<struct FDataTableRowHandle>*     AmmoRowHandles                                         (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetAmmoCount(const struct FGameplayTag& AmmoType, TMap<struct FGameplayTag, int32>* AmmoCounts, TArray<struct FDataTableRowHandle>* AmmoRowHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetAmmoCount");

	Params::BPC_PlayerSaveGames_C_GetAmmoCount Parms{};

	Parms.AmmoType = std::move(AmmoType);

	UObject::ProcessEvent(Func, &Parms);

	if (AmmoCounts != nullptr)
		*AmmoCounts = std::move(Parms.AmmoCounts);

	if (AmmoRowHandles != nullptr)
		*AmmoRowHandles = std::move(Parms.AmmoRowHandles);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetDefaultRig
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle*             DefaultRig                                             (Parm, OutParm, NoDestructor)

void UBPC_PlayerSaveGames_C::GetDefaultRig(struct FDataTableRowHandle* DefaultRig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetDefaultRig");

	Params::BPC_PlayerSaveGames_C_GetDefaultRig Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DefaultRig != nullptr)
		*DefaultRig = std::move(Parms.DefaultRig);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetDefaultWeapons
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedWeapon>*            Weapons                                                (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetDefaultWeapons(TArray<struct FSavedWeapon>* Weapons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetDefaultWeapons");

	Params::BPC_PlayerSaveGames_C_GetDefaultWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weapons != nullptr)
		*Weapons = std::move(Parms.Weapons);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetKnownItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWKnownItems**                   KnownItems_0                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetKnownItems(class UFWKnownItems** KnownItems_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetKnownItems");

	Params::BPC_PlayerSaveGames_C_GetKnownItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (KnownItems_0 != nullptr)
		*KnownItems_0 = Parms.KnownItems_0;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetLoadout
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_PlayerLoadout_C**             Player_Loadout                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetLoadout(class UBP_PlayerLoadout_C** Player_Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetLoadout");

	Params::BPC_PlayerSaveGames_C_GetLoadout Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Player_Loadout != nullptr)
		*Player_Loadout = Parms.Player_Loadout;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetLoadoutWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double*                                 Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 MaxWeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetLoadoutWeight(double* Weight, double* MaxWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetLoadoutWeight");

	Params::BPC_PlayerSaveGames_C_GetLoadoutWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weight != nullptr)
		*Weight = Parms.Weight;

	if (MaxWeight != nullptr)
		*MaxWeight = Parms.MaxWeight;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetMagCapacity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  PrimaryMagCapacity                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  SecondaryMagCapacity                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetMagCapacity(int32* PrimaryMagCapacity, int32* SecondaryMagCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetMagCapacity");

	Params::BPC_PlayerSaveGames_C_GetMagCapacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PrimaryMagCapacity != nullptr)
		*PrimaryMagCapacity = Parms.PrimaryMagCapacity;

	if (SecondaryMagCapacity != nullptr)
		*SecondaryMagCapacity = Parms.SecondaryMagCapacity;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetMedsCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  Medkits                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetMedsCount(int32* Medkits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetMedsCount");

	Params::BPC_PlayerSaveGames_C_GetMedsCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Medkits != nullptr)
		*Medkits = Parms.Medkits;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetNextVendorListIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FString&                    BaseName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32*                                  StartingIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetNextVendorListIndex(const class FString& BaseName, int32* StartingIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetNextVendorListIndex");

	Params::BPC_PlayerSaveGames_C_GetNextVendorListIndex Parms{};

	Parms.BaseName = std::move(BaseName);

	UObject::ProcessEvent(Func, &Parms);

	if (StartingIndex != nullptr)
		*StartingIndex = Parms.StartingIndex;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetRig
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FBackpackRigDefaults*            BackpackRig                                            (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetRig(struct FBackpackRigDefaults* BackpackRig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetRig");

	Params::BPC_PlayerSaveGames_C_GetRig Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BackpackRig != nullptr)
		*BackpackRig = std::move(Parms.BackpackRig);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetRigDanglyCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Dangly                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetRigDanglyCount(class FName Dangly, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetRigDanglyCount");

	Params::BPC_PlayerSaveGames_C_GetRigDanglyCount Parms{};

	Parms.Dangly = Dangly;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetRigItemCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetRigItemCount(class FName Item, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetRigItemCount");

	Params::BPC_PlayerSaveGames_C_GetRigItemCount Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetRigRow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName*                            RigRow                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetRigRow(class FName* RigRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetRigRow");

	Params::BPC_PlayerSaveGames_C_GetRigRow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RigRow != nullptr)
		*RigRow = Parms.RigRow;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetSavedVendorBuyLists
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    ListName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// struct FFWVendorListItems*              VendorList                                             (Parm, OutParm)
// bool*                                   ListFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetSavedVendorBuyLists(const class FString& ListName, struct FFWVendorListItems* VendorList, bool* ListFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetSavedVendorBuyLists");

	Params::BPC_PlayerSaveGames_C_GetSavedVendorBuyLists Parms{};

	Parms.ListName = std::move(ListName);

	UObject::ProcessEvent(Func, &Parms);

	if (VendorList != nullptr)
		*VendorList = std::move(Parms.VendorList);

	if (ListFound != nullptr)
		*ListFound = Parms.ListFound;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetSavedVendorLists
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FString&                    BaseName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// TArray<class FString>*                  VendorLists                                            (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetSavedVendorLists(const class FString& BaseName, TArray<class FString>* VendorLists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetSavedVendorLists");

	Params::BPC_PlayerSaveGames_C_GetSavedVendorLists Parms{};

	Parms.BaseName = std::move(BaseName);

	UObject::ProcessEvent(Func, &Parms);

	if (VendorLists != nullptr)
		*VendorLists = std::move(Parms.VendorLists);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetSaveGame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_PlayerSavedInventory_C**      Stash                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetSaveGame(class UBP_PlayerSavedInventory_C** Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetSaveGame");

	Params::BPC_PlayerSaveGames_C_GetSaveGame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Stash != nullptr)
		*Stash = Parms.Stash;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetSpecifiedCounts
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FDataTableRowHandle>&     TypeRowHandles                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TMap<class FName, struct FSavedItem>*   ItemsCount                                             (Parm, OutParm)
// TMap<class FName, struct FSavedDangly>* DangliesCount                                          (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetSpecifiedCounts(TArray<struct FDataTableRowHandle>& TypeRowHandles, TMap<class FName, struct FSavedItem>* ItemsCount, TMap<class FName, struct FSavedDangly>* DangliesCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetSpecifiedCounts");

	Params::BPC_PlayerSaveGames_C_GetSpecifiedCounts Parms{};

	Parms.TypeRowHandles = std::move(TypeRowHandles);

	UObject::ProcessEvent(Func, &Parms);

	TypeRowHandles = std::move(Parms.TypeRowHandles);

	if (ItemsCount != nullptr)
		*ItemsCount = std::move(Parms.ItemsCount);

	if (DangliesCount != nullptr)
		*DangliesCount = std::move(Parms.DangliesCount);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashContainerCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Container                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetStashContainerCount(const class FName& Container, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashContainerCount");

	Params::BPC_PlayerSaveGames_C_GetStashContainerCount Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashContainers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedContainer>*         Containers                                             (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashContainers(TArray<struct FSavedContainer>* Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashContainers");

	Params::BPC_PlayerSaveGames_C_GetStashContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashCurrencies
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FCurrencyDetails>*        Currencies                                             (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashCurrencies(TArray<struct FCurrencyDetails>* Currencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashCurrencies");

	Params::BPC_PlayerSaveGames_C_GetStashCurrencies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Currencies != nullptr)
		*Currencies = std::move(Parms.Currencies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashCurrencyCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Currency                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int64*                                  Currency_Amount                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetStashCurrencyCount(const class FName& Currency, int64* Currency_Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashCurrencyCount");

	Params::BPC_PlayerSaveGames_C_GetStashCurrencyCount Parms{};

	Parms.Currency = Currency;

	UObject::ProcessEvent(Func, &Parms);

	if (Currency_Amount != nullptr)
		*Currency_Amount = Parms.Currency_Amount;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashDanglies
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedDangly>*            Danglies                                               (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashDanglies(TArray<struct FSavedDangly>* Danglies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashDanglies");

	Params::BPC_PlayerSaveGames_C_GetStashDanglies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Danglies != nullptr)
		*Danglies = std::move(Parms.Danglies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Key                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSavedDangly*                    Dangly                                                 (Parm, OutParm, NoDestructor)

void UBPC_PlayerSaveGames_C::GetStashDangly(const class FName& Key, struct FSavedDangly* Dangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashDangly");

	Params::BPC_PlayerSaveGames_C_GetStashDangly Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (Dangly != nullptr)
		*Dangly = std::move(Parms.Dangly);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashDanglyCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Quantity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetStashDanglyCount(const class FName& Dangly, int32* Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashDanglyCount");

	Params::BPC_PlayerSaveGames_C_GetStashDanglyCount Parms{};

	Parms.Dangly = Dangly;

	UObject::ProcessEvent(Func, &Parms);

	if (Quantity != nullptr)
		*Quantity = Parms.Quantity;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashFrameCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Frame                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetStashFrameCount(const class FName& Frame, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashFrameCount");

	Params::BPC_PlayerSaveGames_C_GetStashFrameCount Parms{};

	Parms.Frame = Frame;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashFrames
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedFrame>*             Frames                                                 (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashFrames(TArray<struct FSavedFrame>* Frames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashFrames");

	Params::BPC_PlayerSaveGames_C_GetStashFrames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Frames != nullptr)
		*Frames = std::move(Parms.Frames);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashItemCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Quantity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetStashItemCount(const class FName& Item, int32* Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashItemCount");

	Params::BPC_PlayerSaveGames_C_GetStashItemCount Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Quantity != nullptr)
		*Quantity = Parms.Quantity;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedItem>*              Items                                                  (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashItems(TArray<struct FSavedItem>* Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashItems");

	Params::BPC_PlayerSaveGames_C_GetStashItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Items != nullptr)
		*Items = std::move(Parms.Items);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashRigs
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FDataTableRowHandle>*     Rigs                                                   (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashRigs(TArray<struct FDataTableRowHandle>* Rigs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashRigs");

	Params::BPC_PlayerSaveGames_C_GetStashRigs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Rigs != nullptr)
		*Rigs = std::move(Parms.Rigs);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashWeaponCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Quantity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetStashWeaponCount(const class FName& Weapon, int32* Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashWeaponCount");

	Params::BPC_PlayerSaveGames_C_GetStashWeaponCount Parms{};

	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);

	if (Quantity != nullptr)
		*Quantity = Parms.Quantity;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetStashWeapons
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FSavedWeapon>*            Weapons                                                (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetStashWeapons(TArray<struct FSavedWeapon>* Weapons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetStashWeapons");

	Params::BPC_PlayerSaveGames_C_GetStashWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weapons != nullptr)
		*Weapons = std::move(Parms.Weapons);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVaultCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       RowHandle                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// int32*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetVaultCount(const struct FDataTableRowHandle& RowHandle, int32* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVaultCount");

	Params::BPC_PlayerSaveGames_C_GetVaultCount Parms{};

	Parms.RowHandle = std::move(RowHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVaultCurrency
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FCurrencyDetails*                Currency                                               (Parm, OutParm, NoDestructor)

void UBPC_PlayerSaveGames_C::GetVaultCurrency(struct FCurrencyDetails* Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVaultCurrency");

	Params::BPC_PlayerSaveGames_C_GetVaultCurrency Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Currency != nullptr)
		*Currency = std::move(Parms.Currency);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVaultItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<struct FGameplayTag, int32>        ReturnValue                                            (Parm, OutParm, ReturnParm)

TMap<struct FGameplayTag, int32> UBPC_PlayerSaveGames_C::GetVaultItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVaultItems");

	Params::BPC_PlayerSaveGames_C_GetVaultItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVaultItemTagFromRow
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       RowHandle                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FGameplayTag*                    Tag                                                    (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// bool*                                   TagFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetVaultItemTagFromRow(const struct FDataTableRowHandle& RowHandle, struct FGameplayTag* Tag, bool* TagFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVaultItemTagFromRow");

	Params::BPC_PlayerSaveGames_C_GetVaultItemTagFromRow Parms{};

	Parms.RowHandle = std::move(RowHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Tag != nullptr)
		*Tag = std::move(Parms.Tag);

	if (TagFound != nullptr)
		*TagFound = Parms.TagFound;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVaultSave
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWWaterVault**                   Vault                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetVaultSave(class UFWWaterVault** Vault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVaultSave");

	Params::BPC_PlayerSaveGames_C_GetVaultSave Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Vault != nullptr)
		*Vault = Parms.Vault;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVendorList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CustomVendorList_C**          VendorShoppingLists_0                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetVendorList(class UBP_CustomVendorList_C** VendorShoppingLists_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVendorList");

	Params::BPC_PlayerSaveGames_C_GetVendorList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (VendorShoppingLists_0 != nullptr)
		*VendorShoppingLists_0 = Parms.VendorShoppingLists_0;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetVendorRebuyItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<struct FGameplayTag, int32>*       RebuyList_0                                            (Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetVendorRebuyItems(TMap<struct FGameplayTag, int32>* RebuyList_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetVendorRebuyItems");

	Params::BPC_PlayerSaveGames_C_GetVendorRebuyItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RebuyList_0 != nullptr)
		*RebuyList_0 = std::move(Parms.RebuyList_0);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetWeapons
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle*             PrimaryWeapon                                          (Parm, OutParm, NoDestructor)
// class FString*                          PrimaryNickname                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          PrimaryFileName                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>*       PrimaryPartsChanged                                    (Parm, OutParm)
// struct FDataTableRowHandle*             SecondaryWeapon                                        (Parm, OutParm, NoDestructor)
// class FString*                          SecondaryNickname                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          SecondaryFileName                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>*       SecondaryPartsChanged                                  (Parm, OutParm)
// struct FDataTableRowHandle*             ThrowWeapon                                            (Parm, OutParm, NoDestructor)
// class FString*                          ThrowNickname                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          ThrowFileName                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::GetWeapons(struct FDataTableRowHandle* PrimaryWeapon, class FString* PrimaryNickname, class FString* PrimaryFileName, TArray<struct FFWWeaponDefaults>* PrimaryPartsChanged, struct FDataTableRowHandle* SecondaryWeapon, class FString* SecondaryNickname, class FString* SecondaryFileName, TArray<struct FFWWeaponDefaults>* SecondaryPartsChanged, struct FDataTableRowHandle* ThrowWeapon, class FString* ThrowNickname, class FString* ThrowFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetWeapons");

	Params::BPC_PlayerSaveGames_C_GetWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PrimaryWeapon != nullptr)
		*PrimaryWeapon = std::move(Parms.PrimaryWeapon);

	if (PrimaryNickname != nullptr)
		*PrimaryNickname = std::move(Parms.PrimaryNickname);

	if (PrimaryFileName != nullptr)
		*PrimaryFileName = std::move(Parms.PrimaryFileName);

	if (PrimaryPartsChanged != nullptr)
		*PrimaryPartsChanged = std::move(Parms.PrimaryPartsChanged);

	if (SecondaryWeapon != nullptr)
		*SecondaryWeapon = std::move(Parms.SecondaryWeapon);

	if (SecondaryNickname != nullptr)
		*SecondaryNickname = std::move(Parms.SecondaryNickname);

	if (SecondaryFileName != nullptr)
		*SecondaryFileName = std::move(Parms.SecondaryFileName);

	if (SecondaryPartsChanged != nullptr)
		*SecondaryPartsChanged = std::move(Parms.SecondaryPartsChanged);

	if (ThrowWeapon != nullptr)
		*ThrowWeapon = std::move(Parms.ThrowWeapon);

	if (ThrowNickname != nullptr)
		*ThrowNickname = std::move(Parms.ThrowNickname);

	if (ThrowFileName != nullptr)
		*ThrowFileName = std::move(Parms.ThrowFileName);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GetWeaponSpawnData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             RowName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>&       Parts                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FFWModifiedPart>*         Changed_Parts                                          (Parm, OutParm)
// struct FFWModifiedStatsPart*            StatsChanged                                           (Parm, OutParm)
// TArray<class FName>*                    ChangedRows                                            (Parm, OutParm)
// struct FFWScopeDefinitions*             ScopeDARow                                             (ConstParm, Parm, OutParm)

void UBPC_PlayerSaveGames_C::GetWeaponSpawnData(class FName RowName, TArray<struct FFWWeaponDefaults>& Parts, TArray<struct FFWModifiedPart>* Changed_Parts, struct FFWModifiedStatsPart* StatsChanged, TArray<class FName>* ChangedRows, struct FFWScopeDefinitions* ScopeDARow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GetWeaponSpawnData");

	Params::BPC_PlayerSaveGames_C_GetWeaponSpawnData Parms{};

	Parms.RowName = RowName;
	Parms.Parts = std::move(Parts);

	UObject::ProcessEvent(Func, &Parms);

	Parts = std::move(Parms.Parts);

	if (Changed_Parts != nullptr)
		*Changed_Parts = std::move(Parms.Changed_Parts);

	if (StatsChanged != nullptr)
		*StatsChanged = std::move(Parms.StatsChanged);

	if (ChangedRows != nullptr)
		*ChangedRows = std::move(Parms.ChangedRows);

	if (ScopeDARow != nullptr)
		*ScopeDARow = std::move(Parms.ScopeDARow);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.GiveExtractedLootXP
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FDataTableRowHandle>&     LootedDanglies                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FDataTableRowHandle>&     LootedItems                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::GiveExtractedLootXP(TArray<struct FDataTableRowHandle>& LootedDanglies, TArray<struct FDataTableRowHandle>& LootedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "GiveExtractedLootXP");

	Params::BPC_PlayerSaveGames_C_GiveExtractedLootXP Parms{};

	Parms.LootedDanglies = std::move(LootedDanglies);
	Parms.LootedItems = std::move(LootedItems);

	UObject::ProcessEvent(Func, &Parms);

	LootedDanglies = std::move(Parms.LootedDanglies);
	LootedItems = std::move(Parms.LootedItems);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Handle Water Overflow
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   WaterBarrelCount                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Handle_Water_Overflow(class UFWPersistenceSubsystem* Subsystem, int32 WaterBarrelCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Handle Water Overflow");

	Params::BPC_PlayerSaveGames_C_Handle_Water_Overflow Parms{};

	Parms.Subsystem = Subsystem;
	Parms.WaterBarrelCount = WaterBarrelCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HandleUnsafeLeave
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::HandleUnsafeLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HandleUnsafeLeave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Has Stash Item
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Has_Stash_Item(const class FName& Item, bool* HasItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Has Stash Item");

	Params::BPC_PlayerSaveGames_C_Has_Stash_Item Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (HasItem != nullptr)
		*HasItem = Parms.HasItem;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasStashContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Container                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasStashContainer(const class FName& Container, bool* HasItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasStashContainer");

	Params::BPC_PlayerSaveGames_C_HasStashContainer Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);

	if (HasItem != nullptr)
		*HasItem = Parms.HasItem;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasStashDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasDangly                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasStashDangly(const class FName& Dangly, bool* HasDangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasStashDangly");

	Params::BPC_PlayerSaveGames_C_HasStashDangly Parms{};

	Parms.Dangly = Dangly;

	UObject::ProcessEvent(Func, &Parms);

	if (HasDangly != nullptr)
		*HasDangly = Parms.HasDangly;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasStashFrame
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Frame                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasStashFrame(const class FName& Frame, bool* HasItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasStashFrame");

	Params::BPC_PlayerSaveGames_C_HasStashFrame Parms{};

	Parms.Frame = Frame;

	UObject::ProcessEvent(Func, &Parms);

	if (HasItem != nullptr)
		*HasItem = Parms.HasItem;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasStashItemByTag
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasStashItemByTag(const struct FGameplayTag& Item, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasStashItemByTag");

	Params::BPC_PlayerSaveGames_C_HasStashItemByTag Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasStashWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasStashWeapon(const class FName& Weapon, bool* HasItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasStashWeapon");

	Params::BPC_PlayerSaveGames_C_HasStashWeapon Parms{};

	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);

	if (HasItem != nullptr)
		*HasItem = Parms.HasItem;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasXStashDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasDangly                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasXStashDangly(const class FName& Dangly, int32 Count, bool* HasDangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasXStashDangly");

	Params::BPC_PlayerSaveGames_C_HasXStashDangly Parms{};

	Parms.Dangly = Dangly;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (HasDangly != nullptr)
		*HasDangly = Parms.HasDangly;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasXStashItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasXStashItem(const class FName& Item, int32 Count, bool* HasItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasXStashItem");

	Params::BPC_PlayerSaveGames_C_HasXStashItem Parms{};

	Parms.Item = Item;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (HasItem != nullptr)
		*HasItem = Parms.HasItem;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.HasXStashWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::HasXStashWeapon(const class FName& Weapon, int32 Count, bool* HasItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "HasXStashWeapon");

	Params::BPC_PlayerSaveGames_C_HasXStashWeapon Parms{};

	Parms.Weapon = Weapon;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (HasItem != nullptr)
		*HasItem = Parms.HasItem;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Is skin intro playing?
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Sequence_Playing_                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Is_skin_intro_playing_(bool* Sequence_Playing_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Is skin intro playing?");

	Params::BPC_PlayerSaveGames_C_Is_skin_intro_playing_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Sequence_Playing_ != nullptr)
		*Sequence_Playing_ = Parms.Sequence_Playing_;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.IsCraftingItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CraftingGroup                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              CraftingRecipy                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool*                                   CraftingGroupActive                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsCrafting                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::IsCraftingItem(const struct FGameplayTag& CraftingGroup, const struct FGameplayTag& CraftingRecipy, bool* CraftingGroupActive, bool* IsCrafting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "IsCraftingItem");

	Params::BPC_PlayerSaveGames_C_IsCraftingItem Parms{};

	Parms.CraftingGroup = std::move(CraftingGroup);
	Parms.CraftingRecipy = std::move(CraftingRecipy);

	UObject::ProcessEvent(Func, &Parms);

	if (CraftingGroupActive != nullptr)
		*CraftingGroupActive = Parms.CraftingGroupActive;

	if (IsCrafting != nullptr)
		*IsCrafting = Parms.IsCrafting;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ItemsExtracted
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FDataTableRowHandle>&ExtractedItem                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const TArray<struct FDataTableRowHandle>&ExtractedDanglies_0                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::ItemsExtracted(const TArray<struct FDataTableRowHandle>& ExtractedItem, const TArray<struct FDataTableRowHandle>& ExtractedDanglies_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ItemsExtracted");

	Params::BPC_PlayerSaveGames_C_ItemsExtracted Parms{};

	Parms.ExtractedItem = std::move(ExtractedItem);
	Parms.ExtractedDanglies_0 = std::move(ExtractedDanglies_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.LoadHUBLoadout
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::LoadHUBLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "LoadHUBLoadout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.LoadPlayerLoadout
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::LoadPlayerLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "LoadPlayerLoadout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.LoadScavMuleData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FContainerItem>*          Mule_Items                                             (Parm, OutParm)
// TArray<struct FDataTableRowHandle>*     Mule_Danglies                                          (Parm, OutParm)

void UBPC_PlayerSaveGames_C::LoadScavMuleData(TArray<struct FContainerItem>* Mule_Items, TArray<struct FDataTableRowHandle>* Mule_Danglies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "LoadScavMuleData");

	Params::BPC_PlayerSaveGames_C_LoadScavMuleData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Mule_Items != nullptr)
		*Mule_Items = std::move(Parms.Mule_Items);

	if (Mule_Danglies != nullptr)
		*Mule_Danglies = std::move(Parms.Mule_Danglies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.OnMessageReceived_6F470716457878B0DD37B8AD4BDBFAF9
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAsyncAction_ListenForGameplayMessage*ProxyObject                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ActualChannel                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::OnMessageReceived_6F470716457878B0DD37B8AD4BDBFAF9(class UAsyncAction_ListenForGameplayMessage* ProxyObject, const struct FGameplayTag& ActualChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "OnMessageReceived_6F470716457878B0DD37B8AD4BDBFAF9");

	Params::BPC_PlayerSaveGames_C_OnMessageReceived_6F470716457878B0DD37B8AD4BDBFAF9 Parms{};

	Parms.ProxyObject = ProxyObject;
	Parms.ActualChannel = std::move(ActualChannel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.PlayerDied
// (BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::PlayerDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "PlayerDied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.QuestAccepted
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWQuest*                         Quest                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::QuestAccepted(class UFWQuest* Quest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "QuestAccepted");

	Params::BPC_PlayerSaveGames_C_QuestAccepted Parms{};

	Parms.Quest = Quest;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Ready_F066582F4AF2534D47AC7391CC92D9E8
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FPersistenceResult&        Result                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::Ready_F066582F4AF2534D47AC7391CC92D9E8(class UFWPersistenceSubsystem* Subsystem, const struct FPersistenceResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Ready_F066582F4AF2534D47AC7391CC92D9E8");

	Params::BPC_PlayerSaveGames_C_Ready_F066582F4AF2534D47AC7391CC92D9E8 Parms{};

	Parms.Subsystem = Subsystem;
	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ReadyRoomWeapon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       DanglyRow                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// class UBP_PlayerLoadout_C*              Loadout                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Weapon                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ReadyRoomWeapon(const struct FDataTableRowHandle& DanglyRow, class UBP_PlayerLoadout_C* Loadout, int32 Weapon, class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ReadyRoomWeapon");

	Params::BPC_PlayerSaveGames_C_ReadyRoomWeapon Parms{};

	Parms.DanglyRow = std::move(DanglyRow);
	Parms.Loadout = Loadout;
	Parms.Weapon = Weapon;
	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBPC_PlayerSaveGames_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveFromVendorRebuy
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              ItemTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::RemoveFromVendorRebuy(const struct FGameplayTag& ItemTag, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveFromVendorRebuy");

	Params::BPC_PlayerSaveGames_C_RemoveFromVendorRebuy Parms{};

	Parms.ItemTag = std::move(ItemTag);
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveLoadoutDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveLoadoutDangly(const struct FDataTableRowHandle& Dangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveLoadoutDangly");

	Params::BPC_PlayerSaveGames_C_RemoveLoadoutDangly Parms{};

	Parms.Dangly = std::move(Dangly);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveLoadoutItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveLoadoutItem(int32 Socket, const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveLoadoutItem");

	Params::BPC_PlayerSaveGames_C_RemoveLoadoutItem Parms{};

	Parms.Socket = Socket;
	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveQuestItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveQuestItems(const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveQuestItems");

	Params::BPC_PlayerSaveGames_C_RemoveQuestItems Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveRigParts
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::RemoveRigParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveRigParts");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashBuddy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedBuddy&               Buddy                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveStashBuddy(const struct FSavedBuddy& Buddy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashBuddy");

	Params::BPC_PlayerSaveGames_C_RemoveStashBuddy Parms{};

	Parms.Buddy = std::move(Buddy);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedContainer&           Container                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveStashContainer(const struct FSavedContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashContainer");

	Params::BPC_PlayerSaveGames_C_RemoveStashContainer Parms{};

	Parms.Container = std::move(Container);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashCurrency
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FCurrencyDetails>&        RemoveCurrencies                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::RemoveStashCurrency(TArray<struct FCurrencyDetails>& RemoveCurrencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashCurrency");

	Params::BPC_PlayerSaveGames_C_RemoveStashCurrency Parms{};

	Parms.RemoveCurrencies = std::move(RemoveCurrencies);

	UObject::ProcessEvent(Func, &Parms);

	RemoveCurrencies = std::move(Parms.RemoveCurrencies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashDangly
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedDangly&              Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_PlayerSaveGames_C::RemoveStashDangly(const struct FSavedDangly& Dangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashDangly");

	Params::BPC_PlayerSaveGames_C_RemoveStashDangly Parms{};

	Parms.Dangly = std::move(Dangly);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashFrame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedFrame&               Frame                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveStashFrame(const struct FSavedFrame& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashFrame");

	Params::BPC_PlayerSaveGames_C_RemoveStashFrame Parms{};

	Parms.Frame = std::move(Frame);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_PlayerSaveGames_C::RemoveStashItem(const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashItem");

	Params::BPC_PlayerSaveGames_C_RemoveStashItem Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashItemByTag
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::RemoveStashItemByTag(const struct FGameplayTag& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashItemByTag");

	Params::BPC_PlayerSaveGames_C_RemoveStashItemByTag Parms{};

	Parms.Item = std::move(Item);
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveStashWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              Weapon                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_PlayerSaveGames_C::RemoveStashWeapon(const struct FSavedWeapon& Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveStashWeapon");

	Params::BPC_PlayerSaveGames_C_RemoveStashWeapon Parms{};

	Parms.Weapon = std::move(Weapon);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveVaultCurrency
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCurrencyDetails&          NewCurrency                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveVaultCurrency(const struct FCurrencyDetails& NewCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveVaultCurrency");

	Params::BPC_PlayerSaveGames_C_RemoveVaultCurrency Parms{};

	Parms.NewCurrency = std::move(NewCurrency);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveVaultItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::RemoveVaultItem(const struct FGameplayTag& Item, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveVaultItem");

	Params::BPC_PlayerSaveGames_C_RemoveVaultItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RemoveVaultQuestItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedItem&                Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::RemoveVaultQuestItems(const struct FSavedItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RemoveVaultQuestItems");

	Params::BPC_PlayerSaveGames_C_RemoveVaultQuestItems Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ResetSave
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWPersistenceSubsystem*          Subsystem                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ResetSave(class UFWPersistenceSubsystem* Subsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ResetSave");

	Params::BPC_PlayerSaveGames_C_ResetSave Parms{};

	Parms.Subsystem = Subsystem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RestoreRigParts
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             RowName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FBackpackRigDefaults&      BackpackRig                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::RestoreRigParts(class FName RowName, const struct FBackpackRigDefaults& BackpackRig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RestoreRigParts");

	Params::BPC_PlayerSaveGames_C_RestoreRigParts Parms{};

	Parms.RowName = RowName;
	Parms.BackpackRig = std::move(BackpackRig);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RestoreWeaponParts
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             RowName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>&       Parts                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::RestoreWeaponParts(class FName RowName, TArray<struct FFWWeaponDefaults>& Parts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RestoreWeaponParts");

	Params::BPC_PlayerSaveGames_C_RestoreWeaponParts Parms{};

	Parms.RowName = RowName;
	Parms.Parts = std::move(Parts);

	UObject::ProcessEvent(Func, &Parms);

	Parts = std::move(Parms.Parts);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RetrieveTombstone
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::RetrieveTombstone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RetrieveTombstone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.RetrieveTombstoneWithBot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  NewDroneCount                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::RetrieveTombstoneWithBot(int32* NewDroneCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "RetrieveTombstoneWithBot");

	Params::BPC_PlayerSaveGames_C_RetrieveTombstoneWithBot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewDroneCount != nullptr)
		*NewDroneCount = Parms.NewDroneCount;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SaveList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    ListName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const struct FFWVendorListItems&        List                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::SaveList(const class FString& ListName, const struct FFWVendorListItems& List)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SaveList");

	Params::BPC_PlayerSaveGames_C_SaveList Parms{};

	Parms.ListName = std::move(ListName);
	Parms.List = std::move(List);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Scav Mule Extract
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           PlayerPawn                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    TunnelsExtract                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Scav_Mule_Extract(class AFWGamePlayerCharacter* PlayerPawn, bool TunnelsExtract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Scav Mule Extract");

	Params::BPC_PlayerSaveGames_C_Scav_Mule_Extract Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.TunnelsExtract = TunnelsExtract;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ScopedRegionDeath
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Map                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ScopedRegionDeath(const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ScopedRegionDeath");

	Params::BPC_PlayerSaveGames_C_ScopedRegionDeath Parms{};

	Parms.Map = std::move(Map);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ScopedRegionEntry
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Map                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ScopedRegionEntry(const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ScopedRegionEntry");

	Params::BPC_PlayerSaveGames_C_ScopedRegionEntry Parms{};

	Parms.Map = std::move(Map);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ScopedRegionExtract
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Map                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ScopedRegionExtract(const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ScopedRegionExtract");

	Params::BPC_PlayerSaveGames_C_ScopedRegionExtract Parms{};

	Parms.Map = std::move(Map);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Set Loadout Items
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<int32, struct FBackpackContainerInfo>&ContainerItems                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::Set_Loadout_Items(const TMap<int32, struct FBackpackContainerInfo>& ContainerItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Set Loadout Items");

	Params::BPC_PlayerSaveGames_C_Set_Loadout_Items Parms{};

	Parms.ContainerItems = std::move(ContainerItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SetCharacterRig
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FBackpackRigDefaults&      CustomSettings                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// class FName                             RigRowFromDataTable                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::SetCharacterRig(const struct FBackpackRigDefaults& CustomSettings, class FName RigRowFromDataTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SetCharacterRig");

	Params::BPC_PlayerSaveGames_C_SetCharacterRig Parms{};

	Parms.CustomSettings = std::move(CustomSettings);
	Parms.RigRowFromDataTable = RigRowFromDataTable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SetCharacterWeapons
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDataTableRowHandle&       Primary                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const TArray<struct FFWModifiedPart>&   PrimayModifiedParts                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FFWModifiedStatsPart&      PrimaryModifiedStats                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FFWScopeDefinitions&       PrimaryScopeDA                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FDataTableRowHandle&       Secondary                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const TArray<struct FFWModifiedPart>&   SecondaryModifiedParts                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FFWModifiedStatsPart&      SecondaryModifiedStats                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FFWScopeDefinitions&       SecondaryScopeDA                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FDataTableRowHandle&       Throw                                                  (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UBPC_PlayerSaveGames_C::SetCharacterWeapons(const struct FDataTableRowHandle& Primary, const TArray<struct FFWModifiedPart>& PrimayModifiedParts, const struct FFWModifiedStatsPart& PrimaryModifiedStats, const struct FFWScopeDefinitions& PrimaryScopeDA, const struct FDataTableRowHandle& Secondary, const TArray<struct FFWModifiedPart>& SecondaryModifiedParts, const struct FFWModifiedStatsPart& SecondaryModifiedStats, const struct FFWScopeDefinitions& SecondaryScopeDA, const struct FDataTableRowHandle& Throw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SetCharacterWeapons");

	Params::BPC_PlayerSaveGames_C_SetCharacterWeapons Parms{};

	Parms.Primary = std::move(Primary);
	Parms.PrimayModifiedParts = std::move(PrimayModifiedParts);
	Parms.PrimaryModifiedStats = std::move(PrimaryModifiedStats);
	Parms.PrimaryScopeDA = std::move(PrimaryScopeDA);
	Parms.Secondary = std::move(Secondary);
	Parms.SecondaryModifiedParts = std::move(SecondaryModifiedParts);
	Parms.SecondaryModifiedStats = std::move(SecondaryModifiedStats);
	Parms.SecondaryScopeDA = std::move(SecondaryScopeDA);
	Parms.Throw = std::move(Throw);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SetPawn
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::SetPawn(class APawn* Pawn_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SetPawn");

	Params::BPC_PlayerSaveGames_C_SetPawn Parms{};

	Parms.Pawn_0 = Pawn_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SetReadyRoom
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::SetReadyRoom(class APlayerState* PlayerState, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SetReadyRoom");

	Params::BPC_PlayerSaveGames_C_SetReadyRoom Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SetRig
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FBackpackRigDefaults&      BackpackRig                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// class FName                             RigRow                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::SetRig(const struct FBackpackRigDefaults& BackpackRig, class FName RigRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SetRig");

	Params::BPC_PlayerSaveGames_C_SetRig Parms{};

	Parms.BackpackRig = std::move(BackpackRig);
	Parms.RigRow = RigRow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SetWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFWWeaponSlot                           WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FDataTableRowHandle&       Weapon_Weapon_Row_Handle                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const class FString&                    Nickname                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    Filename                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>&       ChangedParts                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::SetWeapon(EFWWeaponSlot WeaponSlot, const struct FDataTableRowHandle& Weapon_Weapon_Row_Handle, const class FString& Nickname, const class FString& Filename, TArray<struct FFWWeaponDefaults>& ChangedParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SetWeapon");

	Params::BPC_PlayerSaveGames_C_SetWeapon Parms{};

	Parms.WeaponSlot = WeaponSlot;
	Parms.Weapon_Weapon_Row_Handle = std::move(Weapon_Weapon_Row_Handle);
	Parms.Nickname = std::move(Nickname);
	Parms.Filename = std::move(Filename);
	Parms.ChangedParts = std::move(ChangedParts);

	UObject::ProcessEvent(Func, &Parms);

	ChangedParts = std::move(Parms.ChangedParts);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.Spawn Previous Run Items
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFWTombStoneSave*                 TombStoneSave_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bHadDied                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::Spawn_Previous_Run_Items(class UFWTombStoneSave* TombStoneSave_0, bool bHadDied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "Spawn Previous Run Items");

	Params::BPC_PlayerSaveGames_C_Spawn_Previous_Run_Items Parms{};

	Parms.TombStoneSave_0 = TombStoneSave_0;
	Parms.bHadDied = bHadDied;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SpawnPreviousDangly
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Class_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::SpawnPreviousDangly(const struct FVector& Location, class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SpawnPreviousDangly");

	Params::BPC_PlayerSaveGames_C_SpawnPreviousDangly Parms{};

	Parms.Location = std::move(Location);
	Parms.Class_0 = Class_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.SpawnPreviousItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Class_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSavedItem>&              Items                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBPC_PlayerSaveGames_C::SpawnPreviousItems(const struct FVector& Location, class UClass* Class_0, TArray<struct FSavedItem>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "SpawnPreviousItems");

	Params::BPC_PlayerSaveGames_C_SpawnPreviousItems Parms{};

	Parms.Location = std::move(Location);
	Parms.Class_0 = Class_0;
	Parms.Items = std::move(Items);

	UObject::ProcessEvent(Func, &Parms);

	Items = std::move(Parms.Items);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.UnloadLoadout
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   ConvertedToWeapon                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FName, struct FSavedItem>*   Stashed_Ammo                                           (Parm, OutParm)
// TMap<class FName, struct FSavedWeapon>* StashedWeapons                                         (Parm, OutParm)
// TMap<class FName, struct FSavedItem>*   StashedItems                                           (Parm, OutParm)
// TMap<class FName, struct FSavedDangly>* StashedDanglies                                        (Parm, OutParm)

void UBPC_PlayerSaveGames_C::UnloadLoadout(bool* ConvertedToWeapon, TMap<class FName, struct FSavedItem>* Stashed_Ammo, TMap<class FName, struct FSavedWeapon>* StashedWeapons, TMap<class FName, struct FSavedItem>* StashedItems, TMap<class FName, struct FSavedDangly>* StashedDanglies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "UnloadLoadout");

	Params::BPC_PlayerSaveGames_C_UnloadLoadout Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ConvertedToWeapon != nullptr)
		*ConvertedToWeapon = Parms.ConvertedToWeapon;

	if (Stashed_Ammo != nullptr)
		*Stashed_Ammo = std::move(Parms.Stashed_Ammo);

	if (StashedWeapons != nullptr)
		*StashedWeapons = std::move(Parms.StashedWeapons);

	if (StashedItems != nullptr)
		*StashedItems = std::move(Parms.StashedItems);

	if (StashedDanglies != nullptr)
		*StashedDanglies = std::move(Parms.StashedDanglies);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.UnloadWater
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::UnloadWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "UnloadWater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.UpdateLoadoutDangly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSavedDangly&              Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// bool                                    Loose_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::UpdateLoadoutDangly(int32 Socket, const struct FSavedDangly& Dangly, bool Loose_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "UpdateLoadoutDangly");

	Params::BPC_PlayerSaveGames_C_UpdateLoadoutDangly Parms{};

	Parms.Socket = Socket;
	Parms.Dangly = std::move(Dangly);
	Parms.Loose_ = Loose_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.UpdateLoadoutMultiDangly
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSavedDangly&              Dangly                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void UBPC_PlayerSaveGames_C::UpdateLoadoutMultiDangly(int32 Socket, int32 SlotIndex, const struct FSavedDangly& Dangly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "UpdateLoadoutMultiDangly");

	Params::BPC_PlayerSaveGames_C_UpdateLoadoutMultiDangly Parms{};

	Parms.Socket = Socket;
	Parms.SlotIndex = SlotIndex;
	Parms.Dangly = std::move(Dangly);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.UpdatePlayerLoadout
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::UpdatePlayerLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "UpdatePlayerLoadout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.UpdateVault
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::UpdateVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "UpdateVault");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ValidateLoadout
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_PlayerSaveGames_C::ValidateLoadout(const struct FGameplayTag& CharacterTag, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ValidateLoadout");

	Params::BPC_PlayerSaveGames_C_ValidateLoadout Parms{};

	Parms.CharacterTag = std::move(CharacterTag);

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function BPC_PlayerSaveGames.BPC_PlayerSaveGames_C.ValidateQuests
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_PlayerSaveGames_C::ValidateQuests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_PlayerSaveGames_C", "ValidateQuests");

	UObject::ProcessEvent(Func, nullptr);
}

}

