#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerLoadout

#include "Basic.hpp"

#include "BP_PlayerLoadout_classes.hpp"
#include "BP_PlayerLoadout_parameters.hpp"


namespace SDK
{

// Function BP_PlayerLoadout.BP_PlayerLoadout_C.ApplyNewAesphetics
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const class USkeletalMesh*&             SkeletalMesh                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// const class UMaterialInstance*&         Material                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::ApplyNewAesphetics(const struct FGameplayTag& CharacterTag, const class USkeletalMesh*& SkeletalMesh, const class UMaterialInstance*& Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "ApplyNewAesphetics");

	Params::BP_PlayerLoadout_C_ApplyNewAesphetics Parms{};

	Parms.CharacterTag = std::move(CharacterTag);
	Parms.SkeletalMesh = SkeletalMesh;
	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.CreateDefaultLoadout
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerLoadout_C::CreateDefaultLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "CreateDefaultLoadout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetAesphetics
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class USkeletalMesh**                   Mesh                                                   (ConstParm, Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UMaterialInstance**               Material                                               (ConstParm, Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetAesphetics(const struct FGameplayTag& CharacterTag, class USkeletalMesh** Mesh, class UMaterialInstance** Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetAesphetics");

	Params::BP_PlayerLoadout_C_GetAesphetics Parms{};

	Parms.CharacterTag = std::move(CharacterTag);

	UObject::ProcessEvent(Func, &Parms);

	if (Mesh != nullptr)
		*Mesh = Parms.Mesh;

	if (Material != nullptr)
		*Material = Parms.Material;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetAmmoCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              AmmoType                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TMap<struct FGameplayTag, int32>*       AmmoCounts                                             (Parm, OutParm)
// TArray<struct FDataTableRowHandle>*     AmmoRowHandles                                         (Parm, OutParm)

void UBP_PlayerLoadout_C::GetAmmoCount(const struct FGameplayTag& AmmoType, TMap<struct FGameplayTag, int32>* AmmoCounts, TArray<struct FDataTableRowHandle>* AmmoRowHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetAmmoCount");

	Params::BP_PlayerLoadout_C_GetAmmoCount Parms{};

	Parms.AmmoType = std::move(AmmoType);

	UObject::ProcessEvent(Func, &Parms);

	if (AmmoCounts != nullptr)
		*AmmoCounts = std::move(Parms.AmmoCounts);

	if (AmmoRowHandles != nullptr)
		*AmmoRowHandles = std::move(Parms.AmmoRowHandles);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetCustomMagCount
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              SavedWeapon                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// TArray<struct FFWWeaponDefaults>&       Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32*                                  MagazineCapacity                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetCustomMagCount(const struct FSavedWeapon& SavedWeapon, TArray<struct FFWWeaponDefaults>& Array, int32* MagazineCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetCustomMagCount");

	Params::BP_PlayerLoadout_C_GetCustomMagCount Parms{};

	Parms.SavedWeapon = std::move(SavedWeapon);
	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (MagazineCapacity != nullptr)
		*MagazineCapacity = Parms.MagazineCapacity;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetDanglyCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Dangly                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetDanglyCount(class FName Dangly, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetDanglyCount");

	Params::BP_PlayerLoadout_C_GetDanglyCount Parms{};

	Parms.Dangly = Dangly;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetDefaultMagCount
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSavedWeapon&              SavedWeapon                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// int32*                                  MaxAmmo                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetDefaultMagCount(const struct FSavedWeapon& SavedWeapon, int32* MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetDefaultMagCount");

	Params::BP_PlayerLoadout_C_GetDefaultMagCount Parms{};

	Parms.SavedWeapon = std::move(SavedWeapon);

	UObject::ProcessEvent(Func, &Parms);

	if (MaxAmmo != nullptr)
		*MaxAmmo = Parms.MaxAmmo;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetDefaultRig
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle*             DefaultRig_0                                           (Parm, OutParm, NoDestructor)

void UBP_PlayerLoadout_C::GetDefaultRig(struct FDataTableRowHandle* DefaultRig_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetDefaultRig");

	Params::BP_PlayerLoadout_C_GetDefaultRig Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DefaultRig_0 != nullptr)
		*DefaultRig_0 = std::move(Parms.DefaultRig_0);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetDefaultWeapons
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSavedWeapon*                    DefaultPrimaryWeapon_0                                 (Parm, OutParm, NoDestructor)
// struct FSavedWeapon*                    DefaultSecondaryWeapon_0                               (Parm, OutParm, NoDestructor)
// struct FSavedWeapon*                    DefaultThrowWeapon_0                                   (Parm, OutParm, NoDestructor)

void UBP_PlayerLoadout_C::GetDefaultWeapons(struct FSavedWeapon* DefaultPrimaryWeapon_0, struct FSavedWeapon* DefaultSecondaryWeapon_0, struct FSavedWeapon* DefaultThrowWeapon_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetDefaultWeapons");

	Params::BP_PlayerLoadout_C_GetDefaultWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DefaultPrimaryWeapon_0 != nullptr)
		*DefaultPrimaryWeapon_0 = std::move(Parms.DefaultPrimaryWeapon_0);

	if (DefaultSecondaryWeapon_0 != nullptr)
		*DefaultSecondaryWeapon_0 = std::move(Parms.DefaultSecondaryWeapon_0);

	if (DefaultThrowWeapon_0 != nullptr)
		*DefaultThrowWeapon_0 = std::move(Parms.DefaultThrowWeapon_0);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetItemCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetItemCount(class FName Item, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetItemCount");

	Params::BP_PlayerLoadout_C_GetItemCount Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetLoadoutWeight
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 MaxWeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetLoadoutWeight(double* Weight, double* MaxWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetLoadoutWeight");

	Params::BP_PlayerLoadout_C_GetLoadoutWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weight != nullptr)
		*Weight = Parms.Weight;

	if (MaxWeight != nullptr)
		*MaxWeight = Parms.MaxWeight;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetMagCapacity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  PrimaryMagCapacity                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  SecondaryMagCapacity                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetMagCapacity(int32* PrimaryMagCapacity, int32* SecondaryMagCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetMagCapacity");

	Params::BP_PlayerLoadout_C_GetMagCapacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PrimaryMagCapacity != nullptr)
		*PrimaryMagCapacity = Parms.PrimaryMagCapacity;

	if (SecondaryMagCapacity != nullptr)
		*SecondaryMagCapacity = Parms.SecondaryMagCapacity;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetMedsCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  Medkits                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetMedsCount(int32* Medkits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetMedsCount");

	Params::BP_PlayerLoadout_C_GetMedsCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Medkits != nullptr)
		*Medkits = Parms.Medkits;
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetSpecifiedCounts
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FDataTableRowHandle>&     TypeRowHandles                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TMap<class FName, struct FSavedItem>*   ItemsCount                                             (Parm, OutParm)
// TMap<class FName, struct FSavedDangly>* DangliesCount                                          (Parm, OutParm)

void UBP_PlayerLoadout_C::GetSpecifiedCounts(TArray<struct FDataTableRowHandle>& TypeRowHandles, TMap<class FName, struct FSavedItem>* ItemsCount, TMap<class FName, struct FSavedDangly>* DangliesCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetSpecifiedCounts");

	Params::BP_PlayerLoadout_C_GetSpecifiedCounts Parms{};

	Parms.TypeRowHandles = std::move(TypeRowHandles);

	UObject::ProcessEvent(Func, &Parms);

	TypeRowHandles = std::move(Parms.TypeRowHandles);

	if (ItemsCount != nullptr)
		*ItemsCount = std::move(Parms.ItemsCount);

	if (DangliesCount != nullptr)
		*DangliesCount = std::move(Parms.DangliesCount);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetWeapons
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle*             PrimaryWeapon_0                                        (Parm, OutParm, NoDestructor)
// class FString*                          PrimaryNickname_0                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          PrimaryFileName_0                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>*       PrimaryPartsChanged_0                                  (Parm, OutParm)
// struct FDataTableRowHandle*             SecondaryWeapon_0                                      (Parm, OutParm, NoDestructor)
// class FString*                          SecondaryNickname_0                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          SecondaryFileName_0                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>*       SecondaryPartsChanged_0                                (Parm, OutParm)
// struct FDataTableRowHandle*             ThrowWeapon_0                                          (Parm, OutParm, NoDestructor)
// class FString*                          ThrowNickname_0                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          ThrowFileName_0                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::GetWeapons(struct FDataTableRowHandle* PrimaryWeapon_0, class FString* PrimaryNickname_0, class FString* PrimaryFileName_0, TArray<struct FFWWeaponDefaults>* PrimaryPartsChanged_0, struct FDataTableRowHandle* SecondaryWeapon_0, class FString* SecondaryNickname_0, class FString* SecondaryFileName_0, TArray<struct FFWWeaponDefaults>* SecondaryPartsChanged_0, struct FDataTableRowHandle* ThrowWeapon_0, class FString* ThrowNickname_0, class FString* ThrowFileName_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetWeapons");

	Params::BP_PlayerLoadout_C_GetWeapons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PrimaryWeapon_0 != nullptr)
		*PrimaryWeapon_0 = std::move(Parms.PrimaryWeapon_0);

	if (PrimaryNickname_0 != nullptr)
		*PrimaryNickname_0 = std::move(Parms.PrimaryNickname_0);

	if (PrimaryFileName_0 != nullptr)
		*PrimaryFileName_0 = std::move(Parms.PrimaryFileName_0);

	if (PrimaryPartsChanged_0 != nullptr)
		*PrimaryPartsChanged_0 = std::move(Parms.PrimaryPartsChanged_0);

	if (SecondaryWeapon_0 != nullptr)
		*SecondaryWeapon_0 = std::move(Parms.SecondaryWeapon_0);

	if (SecondaryNickname_0 != nullptr)
		*SecondaryNickname_0 = std::move(Parms.SecondaryNickname_0);

	if (SecondaryFileName_0 != nullptr)
		*SecondaryFileName_0 = std::move(Parms.SecondaryFileName_0);

	if (SecondaryPartsChanged_0 != nullptr)
		*SecondaryPartsChanged_0 = std::move(Parms.SecondaryPartsChanged_0);

	if (ThrowWeapon_0 != nullptr)
		*ThrowWeapon_0 = std::move(Parms.ThrowWeapon_0);

	if (ThrowNickname_0 != nullptr)
		*ThrowNickname_0 = std::move(Parms.ThrowNickname_0);

	if (ThrowFileName_0 != nullptr)
		*ThrowFileName_0 = std::move(Parms.ThrowFileName_0);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.GetWeaponsSpawnData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle*             PrimaryWeapon_0                                        (Parm, OutParm, NoDestructor)
// TArray<struct FFWWeaponDefaults>*       PrimaryChanges                                         (Parm, OutParm)
// struct FDataTableRowHandle*             SecondaryWeapon_0                                      (Parm, OutParm, NoDestructor)
// TArray<struct FFWWeaponDefaults>*       SecondaryChanges                                       (Parm, OutParm)
// struct FDataTableRowHandle*             ThrowWeapon_0                                          (Parm, OutParm, NoDestructor)

void UBP_PlayerLoadout_C::GetWeaponsSpawnData(struct FDataTableRowHandle* PrimaryWeapon_0, TArray<struct FFWWeaponDefaults>* PrimaryChanges, struct FDataTableRowHandle* SecondaryWeapon_0, TArray<struct FFWWeaponDefaults>* SecondaryChanges, struct FDataTableRowHandle* ThrowWeapon_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "GetWeaponsSpawnData");

	Params::BP_PlayerLoadout_C_GetWeaponsSpawnData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PrimaryWeapon_0 != nullptr)
		*PrimaryWeapon_0 = std::move(Parms.PrimaryWeapon_0);

	if (PrimaryChanges != nullptr)
		*PrimaryChanges = std::move(Parms.PrimaryChanges);

	if (SecondaryWeapon_0 != nullptr)
		*SecondaryWeapon_0 = std::move(Parms.SecondaryWeapon_0);

	if (SecondaryChanges != nullptr)
		*SecondaryChanges = std::move(Parms.SecondaryChanges);

	if (ThrowWeapon_0 != nullptr)
		*ThrowWeapon_0 = std::move(Parms.ThrowWeapon_0);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.PatchToBaseWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerLoadout_C::PatchToBaseWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "PatchToBaseWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.ResetAesphetics
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::ResetAesphetics(const struct FGameplayTag& CharacterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "ResetAesphetics");

	Params::BP_PlayerLoadout_C_ResetAesphetics Parms{};

	Parms.CharacterTag = std::move(CharacterTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.ResetLoadout
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlayerLoadout_C::ResetLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "ResetLoadout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.SaveGame
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlayerLoadout_C::SaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "SaveGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.SetNewWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFWWeaponSlot                           WeaponSlot                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSavedWeapon&              Weapon                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const class FString&                    Nickname                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    Filename                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// TArray<struct FFWWeaponDefaults>&       ChangedParts                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_PlayerLoadout_C::SetNewWeapon(EFWWeaponSlot WeaponSlot, const struct FSavedWeapon& Weapon, const class FString& Nickname, const class FString& Filename, TArray<struct FFWWeaponDefaults>& ChangedParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "SetNewWeapon");

	Params::BP_PlayerLoadout_C_SetNewWeapon Parms{};

	Parms.WeaponSlot = WeaponSlot;
	Parms.Weapon = std::move(Weapon);
	Parms.Nickname = std::move(Nickname);
	Parms.Filename = std::move(Filename);
	Parms.ChangedParts = std::move(ChangedParts);

	UObject::ProcessEvent(Func, &Parms);

	ChangedParts = std::move(Parms.ChangedParts);
}


// Function BP_PlayerLoadout.BP_PlayerLoadout_C.SetRig
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FBackpackRigDefaults&      BackpackRig_0                                          (BlueprintVisible, BlueprintReadOnly, Parm)
// class FName                             RigRow_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlayerLoadout_C::SetRig(const struct FBackpackRigDefaults& BackpackRig_0, class FName RigRow_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerLoadout_C", "SetRig");

	Params::BP_PlayerLoadout_C_SetRig Parms{};

	Parms.BackpackRig_0 = std::move(BackpackRig_0);
	Parms.RigRow_0 = RigRow_0;

	UObject::ProcessEvent(Func, &Parms);
}

}

