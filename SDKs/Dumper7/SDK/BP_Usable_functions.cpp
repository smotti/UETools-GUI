#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Usable

#include "Basic.hpp"

#include "BP_Usable_classes.hpp"
#include "BP_Usable_parameters.hpp"


namespace SDK
{

// Function BP_Usable.BP_Usable_C.BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_1_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Usable_C::BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_1_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_1_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_Usable_C_BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_1_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_4_ComponentEndOverlapSignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_4_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_4_ComponentEndOverlapSignature__DelegateSignature");

	Params::BP_Usable_C_BndEvt__BP_Usable_Sphere_K2Node_ComponentBoundEvent_4_ComponentEndOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.CharactersThatCanUse
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class AActor*>*                  Characters_that_can_Use_Me_0                           (Parm, OutParm)

void ABP_Usable_C::CharactersThatCanUse(TArray<class AActor*>* Characters_that_can_Use_Me_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "CharactersThatCanUse");

	Params::BP_Usable_C_CharactersThatCanUse Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Characters_that_can_Use_Me_0 != nullptr)
		*Characters_that_can_Use_Me_0 = std::move(Parms.Characters_that_can_Use_Me_0);
}


// Function BP_Usable.BP_Usable_C.Check For Overlap
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Check_For_Overlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Check For Overlap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.Check Water
// (BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Check_Water()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Check Water");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.ClearTrainingText
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::ClearTrainingText(class UObject* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ClearTrainingText");

	Params::BP_Usable_C_ClearTrainingText Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.Compute Marker Info
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFW_WG_UsableMarker_C*            Widget                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::Compute_Marker_Info(class UFW_WG_UsableMarker_C* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Compute Marker Info");

	Params::BP_Usable_C_Compute_Marker_Info Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.DemoCheck
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::DemoCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "DemoCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.ExecuteUbergraph_BP_Usable
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::ExecuteUbergraph_BP_Usable(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ExecuteUbergraph_BP_Usable");

	Params::BP_Usable_C_ExecuteUbergraph_BP_Usable Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.ExtraDisplayConditions
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Display                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::ExtraDisplayConditions(bool* Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ExtraDisplayConditions");

	Params::BP_Usable_C_ExtraDisplayConditions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Display != nullptr)
		*Display = Parms.Display;
}


// Function BP_Usable.BP_Usable_C.ExtraHostUse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::ExtraHostUse(class AFWGamePlayerCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ExtraHostUse");

	Params::BP_Usable_C_ExtraHostUse Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.ExtraUseConditions
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ApplyHostUseExtra                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   CanUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::ExtraUseConditions(class AFWGamePlayerCharacter* Player, bool ApplyHostUseExtra, bool* CanUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ExtraUseConditions");

	Params::BP_Usable_C_ExtraUseConditions Parms{};

	Parms.Player = Player;
	Parms.ApplyHostUseExtra = ApplyHostUseExtra;

	UObject::ProcessEvent(Func, &Parms);

	if (CanUse != nullptr)
		*CanUse = Parms.CanUse;
}


// Function BP_Usable.BP_Usable_C.Hide or Show Usable Marker
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Hide_                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::Hide_or_Show_Usable_Marker(bool Hide_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Hide or Show Usable Marker");

	Params::BP_Usable_C_Hide_or_Show_Usable_Marker Parms{};

	Parms.Hide_ = Hide_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.I Was Used
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Used_0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::I_Was_Used(class AFWGamePlayerCharacter* Pawn, bool* Used_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "I Was Used");

	Params::BP_Usable_C_I_Was_Used Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Used_0 != nullptr)
		*Used_0 = Parms.Used_0;
}


// Function BP_Usable.BP_Usable_C.Inform Potential Users
// (BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Inform_Potential_Users()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Inform Potential Users");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.LOS Check
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   LOS_passed_                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::LOS_Check(class AFWGamePlayerCharacter* Player, bool* LOS_passed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "LOS Check");

	Params::BP_Usable_C_LOS_Check Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (LOS_passed_ != nullptr)
		*LOS_passed_ = Parms.LOS_passed_;
}


// Function BP_Usable.BP_Usable_C.Overlap Checking
// (BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Overlap_Checking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Overlap Checking");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.PopulateSphere
// (BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::PopulateSphere()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "PopulateSphere");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Usable_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.RemoveCharacterUsable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class AFWGamePlayerCharacter*&    Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::RemoveCharacterUsable(const class AFWGamePlayerCharacter*& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "RemoveCharacterUsable");

	Params::BP_Usable_C_RemoveCharacterUsable Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.RemovePromptText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FText&                      OriginalText                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText ABP_Usable_C::RemovePromptText(const class FText& OriginalText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "RemovePromptText");

	Params::BP_Usable_C_RemovePromptText Parms{};

	Parms.OriginalText = std::move(OriginalText);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Usable.BP_Usable_C.RequestExtraction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Requesting_Pawn                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::RequestExtraction(class AActor* Requesting_Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "RequestExtraction");

	Params::BP_Usable_C_RequestExtraction Parms{};

	Parms.Requesting_Pawn = Requesting_Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.ServerUsed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           PlayerUsed                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::ServerUsed(class AFWGamePlayerCharacter* PlayerUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "ServerUsed");

	Params::BP_Usable_C_ServerUsed Parms{};

	Parms.PlayerUsed = PlayerUsed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.Show Usable Loc
// (BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Show_Usable_Loc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Show Usable Loc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.UpdateUseMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EUseableActorType                       UseMode_0                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::UpdateUseMode(EUseableActorType UseMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "UpdateUseMode");

	Params::BP_Usable_C_UpdateUseMode Parms{};

	Parms.UseMode_0 = UseMode_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.UsableChecks
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AFWGamePlayerCharacter*           Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Usable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::UsableChecks(class AFWGamePlayerCharacter* Player, bool* Usable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "UsableChecks");

	Params::BP_Usable_C_UsableChecks Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (Usable != nullptr)
		*Usable = Parms.Usable;
}


// Function BP_Usable.BP_Usable_C.UseAll
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           PlayerUsed                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::UseAll(class AFWGamePlayerCharacter* PlayerUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "UseAll");

	Params::BP_Usable_C_UseAll Parms{};

	Parms.PlayerUsed = PlayerUsed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Usable.BP_Usable_C.Used
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFWGamePlayerCharacter*           User                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Used_0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          UseableActor                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Usable_C::Used(class AFWGamePlayerCharacter* User, bool* Used_0, class AActor** UseableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Used");

	Params::BP_Usable_C_Used Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);

	if (Used_0 != nullptr)
		*Used_0 = Parms.Used_0;

	if (UseableActor != nullptr)
		*UseableActor = Parms.UseableActor;
}


// Function BP_Usable.BP_Usable_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.Water Allow Usable
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Water_Allow_Usable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Water Allow Usable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.Water Deny Usable
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Water_Deny_Usable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Water Deny Usable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Usable.BP_Usable_C.Water Fail to find row
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Usable_C::Water_Fail_to_find_row()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Usable_C", "Water Fail to find row");

	UObject::ProcessEvent(Func, nullptr);
}

}

